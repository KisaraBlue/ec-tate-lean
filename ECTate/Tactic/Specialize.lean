import Mathlib.Tactic.Basic

import Mathlib.RingTheory.Ideal.Basic



/-!
# The `@[specialize]` attribute.
The attribute `specialize` can be used to automatically transport theorems
and definitions (but not inductive types and structures) from a multiplicative
theory to an additive theory.
-/

open Lean Meta Elab Command Std Tactic.NormCast

/-- Remaining arguments of `specialize`. -/
syntax specializeRest := (ppSpace term)* (ppSpace ident)? (ppSpace str)?
/-- The `specialize` attribute. -/
syntax (name := specialize2) "specialize" "?"? specializeRest : attr

/-- The `specialize` attribute. -/
macro "specialize?" rest:specializeRest : attr => `(attr| specialize ? $rest)

namespace Specialize

/-- `Config` is the type of the arguments that can be provided to `specialize`. -/
structure Config : Type where
  /-- View the trace of the specialize procedure.
  Equivalent to `set_option trace.specialize true`. -/
  trace : Bool := false
  /-- The name of the target (the additive declaration).-/
  tgt : Name := Name.anonymous
  /-- An optional doc string.-/
  doc : Option String := none
  /-- If `allowAutoName` is `false` (default) then
  `@[specialize]` will check whether the given name can be auto-generated. -/
  allowAutoName : Bool := false
  /-- The attributes which we want to give to both the multiplicative and additive versions.
  For certain attributes (such as `simp` and `simps`) this will also add generated lemmas to the
  translation dictionary. -/
  namedArgs : Array Term.NamedArg := #[]
  args : Array Term.Arg := #[]
  ellipsis : Bool
  /-- The `Syntax` element corresponding to the original multiplicative declaration
  (or the `specialize` attribute if it is added later),
  which we need for adding definition ranges. -/
  ref : Syntax
  -- deriving Repr

/-- Elaboration of the configuration options for `specialize`. -/
def elabSpecialize : Syntax → CoreM Config
  | `(attr| specialize%$tk $[?%$trace]? $[$args:term]* $[$tgt]? $[$doc]?) => do
    -- for stx in opts do
    logInfo $ toString $ args
    -- trace[specialize_detail] "attributes: {attrs}; reorder arguments: {reorder}"
    let (namedArgs, args, ellipsis) ← MetaM.run' <| Term.expandArgs args
    return { trace := trace.isSome
             tgt := match tgt with | some tgt => tgt.getId | none => Name.anonymous
             doc := doc.bind (·.raw.isStrLit?)
             allowAutoName := false
             namedArgs := namedArgs
             args := args
             ellipsis := ellipsis
             ref := (tgt.map (·.raw)).getD tk }
  | _ => throwUnsupportedSyntax

def guessName : String → List String → String :=
  fun s t =>
    String.intercalate "_" (s :: t)

/-- Return the provided target name or autogenerate one if one was not provided. -/
def targetName (cfg : Config) (src : Name) : CoreM Name := do
  let .str pre s := src | throwError "specialize: can't transport {src}"
  -- trace[specialize_detail] "The name {s} splits as {s.splitCase}"
  let tgt_auto := guessName s ["spec"]
  -- let depth := cfg.tgt.getNumParts
  -- let pre := pre.mapPrefix <| findTranslation? (← getEnv)
  -- let (pre1, pre2) := pre.splitAt (depth - 1)
  -- if cfg.tgt == pre2.str tgt_auto && !cfg.allowAutoName && cfg.tgt != src then
  --   Linter.logLintIf linter.specializeGenerateName cfg.ref
  --     m!"specialize correctly autogenerated target name for {src}. {"\n"
  --     }You may remove the explicit argument {cfg.tgt}."
  -- let res := if cfg.tgt == .anonymous then pre.str tgt_auto else pre1 ++ cfg.tgt
  -- we allow translating to itself if `tgt == src`, which is occasionally useful for `additiveTest`
  -- if res == src && cfg.tgt != src then
  --   throwError "specialize: can't transport {src} to itself."
  -- if cfg.tgt != .anonymous then
  --   trace[specialize_detail] "The automatically generated name would be {pre.str tgt_auto}"
  return tgt_auto


/-- Find the target name of `pre` and all created auxiliary declarations. -/
def findTargetName (env : Environment) (src pre tgt_pre : Name) : CoreM Name :=
  /- This covers auxiliary declarations like `match_i` and `proof_i`. -/
  if let some post := pre.isPrefixOf? src then
    return tgt_pre ++ post
  /- This covers equation lemmas (for other declarations). -/
  else if let some post := privateToUserName? src then
    -- match findTranslation? env post.getPrefix with
    -- this is an equation lemma for a declaration without `specialize`. We will skip this.
    -- | none =>
    return src
    -- this is an equation lemma for a declaration with `specialize`. We will additivize this.
    -- Note: if this errors we could do this instead by calling `getEqnsFor?`
    -- | some addName => return src.updatePrefix <| mkPrivateName env addName
  -- Note: this additivizes lemmas generated by `simp`.
  -- Todo: we do not currently check whether such lemmas actually should be additivized.
  else if let some post := env.mainModule ++ `_auxLemma |>.isPrefixOf? src then
    return env.mainModule ++ `_auxAddLemma ++ post
  else
    throwError "internal @[specialize] error."


def updateDecl
  (tgt : Name) (srcDecl : ConstantInfo) (args : Array Term.Arg := #[])
  (namedArgs : Array Term.NamedArg := #[]) (ellipsis : Bool)
  : CoreM ConstantInfo :=
MetaM.run' <| Lean.Elab.Term.TermElabM.run' do
  let mut decl := srcDecl.updateName tgt
  --stolen from find
  let mut v := decl.instantiateValueLevelParams! (← mkFreshLevelMVars decl.numLevelParams)
  -- decl := decl.updateType <| ← applyReplacementFun <| ← reorderForall (← expand decl.type) reorder
  -- if let some v := decl.value? then
  --stolen from higher order
  v ← Term.elabAppArgs v namedArgs args none true ellipsis
  v ← Term.levelMVarToParam v
  logInfo v
  -- decl := decl.updateLevelParams v.levelParams
  decl := decl.updateValue v
  -- else throwError "cannot specialize" -- TODO
  decl := decl.updateType (← inferType decl.value!)
  return decl

partial def transformDeclAux
  (cfg : Config) (pre tgt_pre : Name) : Name → CoreM Unit := fun src ↦ do
  let env ← getEnv
  trace[specialize_detail] "visiting {src}"
  -- if we have already translated this declaration, we do nothing.
  -- if (findTranslation? env src).isSome && src != pre then
  --     return
  -- if this declaration is not `pre` and not an internal declaration, we return an error,
  -- since we should have already translated this declaration.
  if src != pre && !src.isInternal' then
    throwError "The declaration {pre} depends on the declaration {src} which is in the namespace {
      pre}, but does not have the `@[specialize]` attribute. This is not supported.\n{""
      }Workaround: move {src} to a different namespace."
  -- we find the additive name of `src`
  let tgt ← findTargetName env src pre tgt_pre
  -- we skip if we already transformed this declaration before.
  if env.contains tgt then
    if tgt == src then
      -- Note: this can happen for equation lemmas of declarations without `@[specialize]`.
      trace[specialize_detail] "Auxiliary declaration {src} will be translated to itself."
    else
      trace[specialize_detail] "Already visited {tgt} as translation of {src}."
    return
  let srcDecl ← getConstInfo src
  -- we first transform all auxiliary declarations generated when elaborating `pre`
  -- for n in findAuxDecls srcDecl.type pre env.mainModule do
  --   transformDeclAux cfg pre tgt_pre n
  -- if let some value := srcDecl.value? then
  --   for n in findAuxDecls value pre env.mainModule do
  --     transformDeclAux cfg pre tgt_pre n
  -- if the auxilliary declaration doesn't have prefix `pre`, then we have to add this declaration
  -- to the translation dictionary, since otherwise we cannot find the additive name.
  -- if !pre.isPrefixOf src then
  --   insertTranslation src tgt
  -- now transform the source declaration
  let trgDecl : ConstantInfo ←
    updateDecl tgt srcDecl cfg.args cfg.namedArgs cfg.ellipsis
  if !trgDecl.hasValue then
    throwError "Expected {tgt} to have a value."
  trace[specialize] "generating\n{tgt} : {trgDecl.type} :=\n  {trgDecl.value!}"
  try
    -- make sure that the type is correct,
    -- and emit a more helpful error message if it fails
    discard <| MetaM.run' <| inferType trgDecl.value!
  catch
    | Exception.error _ msg => throwError "@[specialize] failed.
      Type mismatch in additive declaration. For help, see the docstring
      of `specialize.attr`, section `Troubleshooting`.
      Failed to add declaration\n{tgt}:\n{msg}"
    | _ => panic! "unreachable"
  if isNoncomputable env src then
    addDecl trgDecl.toDeclaration!
    setEnv $ addNoncomputable (← getEnv) tgt
  else
    addAndCompile trgDecl.toDeclaration!
  -- now add declaration ranges so jump-to-definition works
  -- note: we currently also do this for auxiliary declarations, while they are not normally
  -- generated for those. We could change that.
  addDeclarationRanges tgt {
    range := ← getDeclarationRange (← getRef)
    selectionRange := ← getDeclarationRange cfg.ref }
  if isProtected (← getEnv) src then
    setEnv $ addProtected (← getEnv) tgt



partial def transformDecl (cfg : Config) (src tgt : Name) : CoreM (Array Name) := do
  transformDeclAux cfg src tgt src
  -- copyMetaData cfg src tgt
  return #[]

/-- `addToAdditiveAttr src cfg` adds a `@[specialize]` attribute to `src` with configuration `cfg`.
See the attribute implementation for more details.
It returns an array with names of additive declarations (usually 1, but more if there are nested
`specialize` calls. -/
partial def addSpecializeAttr (src : Name) (cfg : Config) (kind := AttributeKind.global) :
  AttrM (Array Name) := do
  if (kind != AttributeKind.global) then
    throwError "`specialize` can only be used as a global attribute"
  -- withOptions (· |>.updateBool `trace.specialize (cfg.trace || ·)) <| do
  let tgt ← targetName cfg src
  let alreadyExists := (← getEnv).contains tgt
  logInfo src
  logInfo tgt
  -- return #[]
  -- if cfg.existing == some !alreadyExists && !(← isInductive src) then
  --   Linter.logLintIf linter.specializeExisting cfg.ref <|
  --     if alreadyExists then
  --       m!"The additive declaration already exists. Please specify this explicitly using {
  --         ""}`@[specialize existing]`."
  --     else
  --       "The additive declaration doesn't exist. Please remove the option `existing`."
  -- let firstMultArg ← MetaM.run' <| firstMultiplicativeArg src
  -- if firstMultArg != 0 then
  --   trace[specialize_detail] "Setting relevant_arg for {src} to be {firstMultArg}."
  --   relevantArgAttr.add src firstMultArg
  -- insertTranslation src tgt alreadyExists
  -- let nestedNames ←
  --   if alreadyExists then
  --     -- since `tgt` already exists, we just need to copy metadata and
  --     -- add translations `src.x ↦ tgt.x'` for any subfields.
  --     trace[specialize_detail] "declaration {tgt} already exists."
  --     proceedFields src tgt
  --     copyMetaData cfg src tgt
  --   else
  --     -- tgt doesn't exist, so let's make it
  transformDecl cfg src tgt
  -- -- add pop-up information when mousing over `additive_name` of `@[specialize additive_name]`
  -- -- (the information will be over the attribute of no additive name is given)
  -- pushInfoLeaf <| .ofTermInfo {
  --   elaborator := .anonymous, lctx := {}, expectedType? := none, isBinder := !alreadyExists,
  --   stx := cfg.ref, expr := ← mkConstWithLevelParams tgt }
  -- if let some doc := cfg.doc then
  --   addDocString tgt doc
  -- return nestedNames.push tgt



initialize registerBuiltinAttribute {
    name := `specialize2
    descr := "Transport multiplicative to additive"
    add := fun src stx kind ↦ do
      _ ← addSpecializeAttr src (← elabSpecialize stx) kind
      -- we (presumably) need to run after compilation to properly add the `simp` attribute
    applicationTime := .afterCompilation
  }


end Specialize
