<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Elab.SyntheticMVars</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Elab.SyntheticMVars";</script><script type="module" src="../.././nav.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within">Lean.Elab.SyntheticMVars</p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib_docs"></input><input type="text" name="q" autocomplete="off"></input><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top">Lean.Elab.SyntheticMVars</a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean/Util/ForEachExpr.html">Lean.Util.ForEachExpr</a></li><li><a href="../.././Lean/Util/OccursCheck.html">Lean.Util.OccursCheck</a></li><li><a href="../.././Lean/Elab/Tactic/Basic.html">Lean.Elab.Tactic.Basic</a></li><li><a href="../.././Lean/Meta/Tactic/Util.html">Lean.Meta.Tactic.Util</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Elab.SyntheticMVars" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.reportStuckSyntheticMVar">Lean.Elab.Term.reportStuckSyntheticMVar</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.runTactic">Lean.Elab.Term.runTactic</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.synthesizeSyntheticMVars">Lean.Elab.Term.synthesizeSyntheticMVars</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.synthesizeSyntheticMVars.loop">Lean.Elab.Term.synthesizeSyntheticMVars.loop</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing">Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault">Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.withSynthesize">Lean.Elab.Term.withSynthesize</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.withSynthesizeLight">Lean.Elab.Term.withSynthesizeLight</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.elabTermAndSynthesize">Lean.Elab.Term.elabTermAndSynthesize</a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.runPendingTacticsAt">Lean.Elab.Term.runPendingTacticsAt</a></div></nav><main>
<div class="decl" id="Lean.Elab.Term.reportStuckSyntheticMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L209-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.reportStuckSyntheticMVar">Lean.Elab.Term.reportStuckSyntheticMVar</a></span><span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(ignoreStuckTC : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>We use this method to report typeclass (and coercion) resolution problems that are "stuck".
That is, there is nothing else to do, and we don't have enough information to synthesize them using TC resolution.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.runTactic"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L295-L325">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runTactic">Lean.Elab.Term.runTactic</a></span><span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(tacticCode : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Try to synthesize a term <code>val</code> using the tactic code <code>tacticCode</code>, and then assign <code>mvarId := val</code>.</p></div></div><div class="decl" id="Lean.Elab.Term.synthesizeSyntheticMVars"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L392-L427">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars">Lean.Elab.Term.synthesizeSyntheticMVars</a></span><span class="decl_args">
<span class="fn">(mayPostpone : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ignoreStuckTC : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Try to process pending synthetic metavariables. If <code>mayPostpone == false</code>,
then <code>pendingMVars</code> is <code>[]</code> after executing this method.</p><p>It keeps executing <code>synthesizeSyntheticMVarsStep</code> while progress is being made.
If <code>mayPostpone == false</code>, then it applies default instances to <code>SyntheticMVarKind.typeClass</code> (if available)
metavariables that are still unresolved, and then tries to resolve metavariables
with <code>mayPostpone == false</code>. That is, we force them to produce error messages and/or commit to
a "best option". If, after that, we still haven't made progress, we report "stuck" errors.</p><p>Remark: we set <code>ignoreStuckTC := true</code> when elaborating <code>simp</code> arguments. Then,
pending TC problems become implicit parameters for the simp theorem.</p></div></div><div class="decl" id="Lean.Elab.Term.synthesizeSyntheticMVars.loop"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L393-L424">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars.loop">Lean.Elab.Term.synthesizeSyntheticMVars.loop</a></span><span class="decl_args">
<span class="fn">(mayPostpone : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ignoreStuckTC : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Unit">Unit</a> â†’ <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div></div></div><div class="decl" id="Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L430-L431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing">Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a></span><span class="decl_args">
<span class="fn">(ignoreStuckTC : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing">Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a> <span class="fn">ignoreStuckTC</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars">Lean.Elab.Term.synthesizeSyntheticMVars</a> <a href="../.././Init/Prelude.html#Bool.false">false</a> <span class="fn">ignoreStuckTC</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L439-L441">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault">Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault">Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  <span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.synthesizeSyntheticMVars">Lean.Elab.Term.synthesizeSyntheticMVars</a> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>
  <a href="../.././Lean/Elab/SyntheticMVars.html#_private.Lean.Elab.SyntheticMVars.0.Lean.Elab.Term.synthesizeUsingDefaultLoop">Lean.Elab.Term.synthesizeUsingDefaultLoop</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.withSynthesize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L459-L460">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesize">Lean.Elab.Term.withSynthesize</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> â†’ <span class="fn">Type u_1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <span class="fn">Type</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">m</span> <span class="fn">Î±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mayPostpone : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">Î±</span></span></div></div><p>Execute <code>k</code>, and synthesize pending synthetic metavariables created while executing <code>k</code> are solved.
If <code>mayPostpone == false</code>, then all of them must be synthesized.
Remark: even if <code>mayPostpone == true</code>, the method still uses <code>synthesizeUsingDefault</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesize">Lean.Elab.Term.withSynthesize</a> <span class="fn">k</span> <span class="fn">mayPostpone</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> (<span class="fn">fun {<span class="fn">Î²</span>} <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#_private.Lean.Elab.SyntheticMVars.0.Lean.Elab.Term.withSynthesizeImp">Lean.Elab.Term.withSynthesizeImp</a> <span class="fn">x</span> <span class="fn">mayPostpone</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span>) <span class="fn">k</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.withSynthesizeLight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L463-L464">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesizeLight">Lean.Elab.Term.withSynthesizeLight</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> â†’ <span class="fn">Type u_1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <span class="fn">Type</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">m</span> <span class="fn">Î±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">Î±</span></span></div></div><p>Similar to <code><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesize">withSynthesize</a></code>, but sets <code>mayPostpone</code> to <code>true</code>, and do not use <code>synthesizeUsingDefault</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.withSynthesizeLight">Lean.Elab.Term.withSynthesizeLight</a> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> (<span class="fn">fun {<span class="fn">Î²</span>} <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Lean/Elab/SyntheticMVars.html#_private.Lean.Elab.SyntheticMVars.0.Lean.Elab.Term.withSynthesizeImp">Lean.Elab.Term.withSynthesizeImp</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>) <span class="fn">k</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.elabTermAndSynthesize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L467-L469">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.elabTermAndSynthesize">Lean.Elab.Term.elabTermAndSynthesize</a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(expectedType? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Elaborate <code>stx</code>, and make sure all pending synthetic metavariables created while elaborating <code>stx</code> are solved.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.runPendingTacticsAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/SyntheticMVars.lean#L476-L482">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runPendingTacticsAt">Lean.Elab.Term.runPendingTacticsAt</a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Collect unassigned metavariables at <code>e</code> that have associated tactic blocks, and then execute them using <code><a href="../.././Lean/Elab/SyntheticMVars.html#Lean.Elab.Term.runTactic">runTactic</a></code>.
We use this method at the <code>match .. with</code> elaborator when it cannot be postponed anymore, but it is still waiting
the result of a tactic block.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././/navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>