<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Tactics</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Tactics";</script><script type="module" src=".././nav.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within">Init.Tactics</p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib_docs"></input><input type="text" name="q" autocomplete="off"></input><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top">Init.Tactics</a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Notation.html">Init.Notation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Tactics" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withAnnotateState">Lean.Parser.Tactic.withAnnotateState</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intro">Lean.Parser.Tactic.intro</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intros">Lean.Parser.Tactic.intros</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rename">Lean.Parser.Tactic.rename</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.revert">Lean.Parser.Tactic.revert</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.clear">Lean.Parser.Tactic.clear</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.subst">Lean.Parser.Tactic.subst</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.apply">Lean.Parser.Tactic.apply</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.exact">Lean.Parser.Tactic.exact</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine">Lean.Parser.Tactic.refine</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine'">Lean.Parser.Tactic.refine'</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case">Lean.Parser.Tactic.case</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case'">Lean.Parser.Tactic.case'</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticNext_=>_»">Lean.Parser.Tactic.«tacticNext_=>_»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.allGoals">Lean.Parser.Tactic.allGoals</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.anyGoals">Lean.Parser.Tactic.anyGoals</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.focus">Lean.Parser.Tactic.focus</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceMessage">Lean.Parser.Tactic.traceMessage</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.failIfSuccess">Lean.Parser.Tactic.failIfSuccess</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.paren">Lean.Parser.Tactic.paren</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducible">Lean.Parser.Tactic.withReducible</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducibleAndInstances">Lean.Parser.Tactic.withReducibleAndInstances</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withUnfoldingAll">Lean.Parser.Tactic.withUnfoldingAll</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.first">Lean.Parser.Tactic.first</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateLeft">Lean.Parser.Tactic.rotateLeft</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateRight">Lean.Parser.Tactic.rotateRight</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTry_">Lean.Parser.Tactic.tacticTry_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tactic_<;>_»">Lean.Parser.Tactic.«tactic_<;>_»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.acRfl">Lean.Parser.Tactic.acRfl</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.change">Lean.Parser.Tactic.change</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.changeWith">Lean.Parser.Tactic.changeWith</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rewriteSeq">Lean.Parser.Tactic.rewriteSeq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwSeq">Lean.Parser.Tactic.rwSeq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injection">Lean.Parser.Tactic.injection</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injections">Lean.Parser.Tactic.injections</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simp">Lean.Parser.Tactic.simp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpAll">Lean.Parser.Tactic.simpAll</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimp">Lean.Parser.Tactic.dsimp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.delta">Lean.Parser.Tactic.delta</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.unfold">Lean.Parser.Tactic.unfold</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift_">Lean.Parser.Tactic.tacticRefine_lift_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave_">Lean.Parser.Tactic.tacticHave_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSuffices_">Lean.Parser.Tactic.tacticSuffices_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet_">Lean.Parser.Tactic.tacticLet_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticShow_">Lean.Parser.Tactic.tacticShow_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.letrec">Lean.Parser.Tactic.letrec</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift'_">Lean.Parser.Tactic.tacticRefine_lift'_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave'_">Lean.Parser.Tactic.tacticHave'_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticHave'_:=_»">Lean.Parser.Tactic.«tacticHave'_:=_»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet'_">Lean.Parser.Tactic.tacticLet'_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.induction">Lean.Parser.Tactic.induction</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalize">Lean.Parser.Tactic.generalize</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.cases">Lean.Parser.Tactic.cases</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.renameI">Lean.Parser.Tactic.renameI</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRepeat_">Lean.Parser.Tactic.tacticRepeat_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.split">Lean.Parser.Tactic.split</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dbgTrace">Lean.Parser.Tactic.dbgTrace</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticStop_">Lean.Parser.Tactic.tacticStop_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.specialize">Lean.Parser.Tactic.specialize</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticUnhygienic_">Lean.Parser.Tactic.tacticUnhygienic_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.fail">Lean.Parser.Tactic.fail</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.checkpoint">Lean.Parser.Tactic.checkpoint</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sleep">Lean.Parser.Tactic.sleep</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticExists_,,»">Lean.Parser.Tactic.«tacticExists_,,»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.congr">Lean.Parser.Tactic.congr</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.simp">Lean.Parser.Attr.simp</a></div><div class="nav_link"><a class="break_within" href="#«term‹_›»">«term‹_›»</a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic_trivial">tacticGet_elem_tactic_trivial</a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic">tacticGet_elem_tactic</a></div><div class="nav_link"><a class="break_within" href="#«term__[_]»">«term__[_]»</a></div><div class="nav_link"><a class="break_within" href="#«term__[_]'_»">«term__[_]'_»</a></div></nav><main>
<div class="decl" id="Lean.Parser.Tactic.withAnnotateState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L11-L16">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">Lean.Parser.Tactic.withAnnotateState</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_annotate_state stx t</code> annotates the lexical range of <code>stx : Syntax</code> with
the initial and final state of running tactic <code>t</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L18-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">Lean.Parser.Tactic.intro</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code>let</code> or function type.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x y</code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code>_</code>, or matched against a pattern:
<pre><code class="language-lean">-- ... ⊢ α × β → ...
<a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> (a, b)
-- ..., a : α, b : β ⊢ ...
</code></pre>
</li>
<li>Alternatively, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> can be combined with pattern matching much like <code>fun</code>:
<pre><code class="language-lean"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>
| n + 1, 0 => tac
| ...
</code></pre>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L41-L45">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">Lean.Parser.Tactic.intros</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a> x...</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x...</code>, but then keeps introducing (anonymous)
hypotheses until goal is not of a function type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rename"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L47-L51">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rename">Lean.Parser.Tactic.rename</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rename">rename</a> t => x</code> renames the most recent hypothesis whose type matches <code>t</code>
(which may contain placeholders) to <code>x</code>, or fails if no such hypothesis could be found.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.revert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L53-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.revert">Lean.Parser.Tactic.revert</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.revert">revert</a> x...</code> is the inverse of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x...</code>: it moves the given hypotheses
into the main goal's target type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L59-L63">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.clear">Lean.Parser.Tactic.clear</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.clear">clear</a> x...</code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L65-L70">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">Lean.Parser.Tactic.subst</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a> x...</code> substitutes each <code>x</code> with <code>e</code> in the goal if there is a hypothesis
of type <code>x = e</code> or <code>e = x</code>.
If <code>x</code> is itself a hypothesis of type <code>y = e</code> or <code>e = y</code>, <code>y</code> is substituted instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.substVars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L72-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a></code> to all hypotheses of the form <code>h : x = t</code> or <code>h : t = x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.substVars</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotsubst_vars&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.assumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L77-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‹t›</code> term notation, which is a shorthand for <code>show t by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.assumption</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotassumption&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.contradiction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L83-L106">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code> closes the main goal if its hypotheses are "trivially contradictory".</p><ul>
<li>Inductive type/family with no applicable constructors</li>
</ul><pre><code class="language-lean">example (h : False) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Injectivity of constructors</li>
</ul><pre><code class="language-lean">example (h : none = some true) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>  --
</code></pre><ul>
<li>Decidable false proposition</li>
</ul><pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Contradictory hypotheses</li>
</ul><pre><code class="language-lean">example (h : p) (h' : ¬ p) : q := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Other simple contradictions such as</li>
</ul><pre><code class="language-lean">example (x : Nat) (h : x ≠ x) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.contradiction</span> <span class="fn">1024</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotcontradiction&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.apply"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L108-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">Lean.Parser.Tactic.apply</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> e</code> tries to match the current goal against the conclusion of <code>e</code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.exact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L119-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">Lean.Parser.Tactic.exact</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code> closes the main goal if its target type matches that of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L124-L129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">Lean.Parser.Tactic.refine</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>)
holes in <code>e</code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L131-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">Lean.Parser.Tactic.refine'</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code>, except that unsolved placeholders (<code>_</code>)
and implicit parameters are also converted into new goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.constructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L137-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If the main goal's target type is an inductive type, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">constructor</a></code> solves it with
the first matching constructor, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.constructor</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotconstructor&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L143-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case">Lean.Parser.Tactic.case</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag => tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>,
or else fails.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag x₁ ... xₙ => tac</code> additionally renames the <code>n</code> most recent hypotheses
with inaccessible names to the given names.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag₁ | tag₂ => tac</code> is equivalent to <code>(case tag₁ => tac); (case tag₂ => tac)</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L152-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case'">Lean.Parser.Tactic.case'</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case'">case'</a></code> is similar to the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag => tac</code> tactic, but does not ensure the goal
has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed.
Recall that <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticNext_=>_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L165-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=>_»">Lean.Parser.Tactic.«tacticNext_=>_»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>next => tac</code> focuses on the next goal and solves it using <code>tac</code>, or else fails.
<code>next x₁ ... xₙ => tac</code> additionally renames the <code>n</code> most recent hypotheses with
inaccessible names to the given names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.allGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.allGoals">Lean.Parser.Tactic.allGoals</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>all_goals tac</code> runs <code>tac</code> on each goal, concatenating the resulting goals, if any.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.anyGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L170-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.anyGoals">Lean.Parser.Tactic.anyGoals</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>any_goals tac</code> applies the tactic <code>tac</code> to every goal, and succeeds if at
least one application succeeds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.focus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L176-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.focus">Lean.Parser.Tactic.focus</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.focus">focus</a> tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>· tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.skip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L182-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code> does nothing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.skip</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotskip&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.done"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L185-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.done">done</a></code> succeeds iff there are no remaining goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.done</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotdone&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L188-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace_state</code> displays the current state in the info view.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.traceState</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quottrace_state&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceMessage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceMessage">Lean.Parser.Tactic.traceMessage</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace msg</code> displays <code>msg</code> in the info view.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.failIfSuccess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L194-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess">Lean.Parser.Tactic.failIfSuccess</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>fail_if_success t</code> fails if the tactic <code>t</code> succeeds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L197-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.paren">Lean.Parser.Tactic.paren</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>(tacs)</code> executes a list of tactics in sequence, without requiring that
the goal be closed at the end like <code>· tacs</code>. Like <code>by</code> itself, the tactics
can be either separated by newlines or <code>;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L204-L208">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducible">Lean.Parser.Tactic.withReducible</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible tacs</code> excutes <code>tacs</code> using the reducible transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducibleAndInstances"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L210-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances">Lean.Parser.Tactic.withReducibleAndInstances</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible_and_instances tacs</code> excutes <code>tacs</code> using the <code>.instances</code> transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> or type class instances are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withUnfoldingAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L216-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">Lean.Parser.Tactic.withUnfoldingAll</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_unfolding_all tacs</code> excutes <code>tacs</code> using the <code>.all</code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.first"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L222-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.first">Lean.Parser.Tactic.first</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a> | tac | ...</code> runs each <code>tac</code> until one succeeds, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L225-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateLeft">Lean.Parser.Tactic.rotateLeft</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rotate_left n</code> rotates goals to the left by <code>n</code>. That is, <code>rotate_left 1</code>
takes the main goal and puts it to the back of the subgoal list.
If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L232-L236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateRight">Lean.Parser.Tactic.rotateRight</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Rotate the goals to the right by <code>n</code>. That is, take the goal at the back
and push it to the front <code>n</code> times. If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTry_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L239-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">Lean.Parser.Tactic.tacticTry_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>try tac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tactic_<;>_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L245-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»">Lean.Parser.Tactic.«tactic_<;>_»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>tac <;> tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L252-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>eq_refl</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.refl</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quoteq_refl&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L260-L260">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a></code> tries to close the current goal using reflexivity.
This is supposed to be an extensible tactic and users can add their own support
for new reflexive relations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotrfl&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L266-L266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rfl'</code> is similar to <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl'</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotrfl'&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.acRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L268-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.acRfl">Lean.Parser.Tactic.acRfl</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>ac_rfl</code> proves equalities up to application of an associative and commutative operator.</p><pre><code>instance : IsAssociative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩
instance : IsCommutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.acRfl">Lean.Parser.Tactic.acRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.acRfl</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotac_rfl&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L286-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>sorry</code> tactic closes the goal using <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code>. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it, but
you can double check if a theorem depends on <code>sorry</code> by using
<code>#print axioms my_thm</code> and looking for <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code> in the axiom list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticSorry</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotsorry&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticAdmit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>admit</code> is a shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> sorry</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticAdmit</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotadmit&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticInfer_instance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>infer_instance</code> is an abbreviation for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code>.
It synthesizes a value of any target type by typeclass inference.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticInfer_instance</span> <span class="fn">1024</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotinfer_instance&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.config"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Optional configuration option for tactics</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationWildcard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>*</code> location refers to all hypotheses and the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quotlocationWildcard&quot</span> <span class="fn">`Lean.Parser.Tactic.locationWildcard</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot*&quot</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationHyp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L303-L307">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A hypothesis location specification consists of 1 or more hypothesis references
and optionally <code>⊢</code> denoting the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.location"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L309-L318">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:</p><ul>
<li>'empty' is not actually present in this syntax, but most tactics use
<code>(location)?</code> matchers. It means to target the goal only.</li>
<li><code>at h₁ ... hₙ</code>: target the hypotheses <code>h₁</code>, ..., <code>hₙ</code></li>
<li><code>at h₁ h₂ ⊢</code>: target the hypotheses <code>h₁</code> and <code>h₂</code>, and the goal</li>
<li><code>at *</code>: target all hypotheses and the goal</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.change"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L320-L326">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.change">Lean.Parser.Tactic.change</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> tgt'</code> will change the goal from <code>tgt</code> to <code>tgt'</code>,
assuming these are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> t' at h</code> will change hypothesis <code>h : t</code> to have type <code>t'</code>, assuming
assuming <code>t</code> and <code>t'</code> are definitionally equal.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.changeWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L328-L333">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.changeWith">Lean.Parser.Tactic.changeWith</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b</code> will change occurrences of <code>a</code> to <code>b</code> in the goal,
assuming <code>a</code> and <code>b</code> are are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b at h</code> similarly changes <code>a</code> to <code>b</code> in the type of hypothesis <code>h</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L335-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If <code>thm</code> is a theorem <code>a = b</code>, then as a rewrite rule,</p><ul>
<li><code>thm</code> means to replace <code>a</code> with <code>b</code>, and</li>
<li><code>← thm</code> means to replace <code>b</code> with <code>a</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRuleSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L341-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">rwRuleSeq</a></code> is a list of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule">rwRule</a></code> in brackets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L344-L354">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq">Lean.Parser.Tactic.rewriteSeq</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rewrite [e]</code> applies identity <code>e</code> as a rewrite rule to the target of the main goal.
If <code>e</code> is preceded by left arrow (<code>←</code> or <code><-</code>), the rewrite is applied in the reverse direction.
If <code>e</code> is a defined constant, then the equational theorems associated with <code>e</code> are used.
This provides a convenient way to unfold <code>e</code>.</p><ul>
<li><code>rewrite [e₁, ..., eₙ]</code> applies the given rules sequentially.</li>
<li><code>rewrite [e] at l</code> rewrites <code>e</code> at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L359-L364">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwSeq">Lean.Parser.Tactic.rwSeq</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by "cheap" (reducible) <code><a href=".././Init/Prelude.html#rfl">rfl</a></code> afterwards.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L366-L379">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">Lean.Parser.Tactic.injection</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code>c</code> is a constructor of an inductive datatype, and if <code>(c t₁)</code>
and <code>(c t₂)</code> are two terms that are equal then  <code>t₁</code> and <code>t₂</code> are equal too.
If <code>q</code> is a proof of a statement of conclusion <code>t₁ = t₂</code>, then injection applies
injectivity to derive the equality of all arguments of <code>t₁</code> and <code>t₂</code> placed in
the same positions. For example, from <code>(a::b) = (c::d)</code> we derive <code>a=c</code> and <code>b=d</code>.
To use this tactic <code>t₁</code> and <code>t₂</code> should be constructor applications of the same constructor.
Given <code>h : a::b = c::d</code>, the tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h</code> adds two new hypothesis with types
<code>a = c</code> and <code>b = d</code> to the main goal.
The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h with h₁ h₂</code> uses the names <code>h₁</code> and <code>h₂</code> to name the new hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injections"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L381-L385">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injections">Lean.Parser.Tactic.injections</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injections">injections</a></code> applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> to all hypotheses recursively
(since <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code>(a::b::c) = (d::e::f)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.discharger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L387-L391">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The discharger clause of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> and related tactics.
This is a tactic used to discharge the side conditions on conditional rewrite rules.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPre"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L393-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule before entering the subterms</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quotsimpPre&quot</span> <span class="fn">`Lean.Parser.Tactic.simpPre</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot↓&quot</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPost"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L395-L396">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule after entering the subterms</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quotsimpPost&quot</span> <span class="fn">`Lean.Parser.Tactic.simpPost</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot↑&quot</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L397-L403">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A simp lemma specification is:</p><ul>
<li>optional <code>↑</code> or <code>↓</code> to specify use before or after entering the subterm</li>
<li>optional <code>←</code> to use the lemma backward</li>
<li><code>thm</code> for the theorem to rewrite with</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpErase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L404-L405">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An erasure specification <code>-thm</code> says to remove <code>thm</code> from the simp set</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpStar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L406-L407">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The simp lemma specification <code>*</code> means to rewrite with all hypotheses</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quotsimpStar&quot</span> <span class="fn">`Lean.Parser.Tactic.simpStar</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot*&quot</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L408-L429">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">Lean.Parser.Tactic.simp</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code> and the given <code>hᵢ</code>'s, where the <code>hᵢ</code>'s are expressions.
If an <code>hᵢ</code> is a defined constant <code>f</code>, then the equational lemmas associated with
<code>f</code> are used. This provides a convenient way to unfold <code>f</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*]</code> simplifies the main goal target using the lemmas tagged with the
attribute <code>[simp]</code> and all hypotheses.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [h₁, h₂, ..., hₙ]</code> is like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> but does not use <code>[simp]</code> lemmas.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [-id₁, ..., -idₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code>, but removes the ones named <code>idᵢ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at h₁ h₂ ... hₙ</code> simplifies the hypotheses <code>h₁ : T₁</code> ... <code>hₙ : Tₙ</code>. If
the target or another hypothesis depends on <code>hᵢ</code>, a new simplified hypothesis
<code>hᵢ</code> is introduced, but the old one remains in the local context.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at *</code> simplifies all the hypotheses and the target.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L430-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpAll">Lean.Parser.Tactic.simpAll</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp_all</code> is a stronger version of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> where the hypotheses and target
are simplified multiple times until no simplication is applicable.
Only non-dependent propositional hypotheses are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L438-L444">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">Lean.Parser.Tactic.dsimp</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code> tactic is the definitional simplifier. It is similar to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L446-L451">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">Lean.Parser.Tactic.delta</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a> id1 id2 ...</code> delta-expands the definitions <code>id1</code>, <code>id2</code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.unfold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L453-L461">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">Lean.Parser.Tactic.unfold</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> <a href=".././Init/Prelude.html#id">id</a></code> unfolds definition <code><a href=".././Init/Prelude.html#id">id</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1 id2 ...</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1; <a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id2; ...</code>.</li>
</ul><p>For non-recursive definitions, this tactic is identical to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a></code>.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L467-L467">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_">Lean.Parser.Tactic.tacticRefine_lift_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Auxiliary macro for lifting have/suffices/let/...
It makes sure the "continuation" <code>?_</code> is the main goal after refining.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L479-L479">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave_">Lean.Parser.Tactic.tacticHave_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>have h : t := e</code> adds the hypothesis <code>h : t</code> to the current goal if <code>e</code> a term
of type <code>t</code>.</p><ul>
<li>If <code>t</code> is omitted, it will be inferred.</li>
<li>If <code>h</code> is omitted, the name <code>this</code> is used.</li>
<li>The variant <code>have pattern := e</code> is equivalent to <code>match e with | pattern => _</code>,
and it is convenient for types that have only one applicable constructor.
For example, given <code>h : p ∧ q ∧ r</code>, <code>have ⟨h₁, h₂, h₃⟩ := h</code> produces the
hypotheses <code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSuffices_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L488-L488">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_">Lean.Parser.Tactic.tacticSuffices_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a main goal <code>ctx ⊢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ⊢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L497-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet_">Lean.Parser.Tactic.tacticLet_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>let h : t := e</code> adds the hypothesis <code>h : t := e</code> to the current goal if <code>e</code> a term of type <code>t</code>.
If <code>t</code> is omitted, it will be inferred.
The variant <code>let pattern := e</code> is equivalent to <code>match e with | pattern => _</code>,
and it is convenient for types that have only applicable constructor.
Example: given <code>h : p ∧ q ∧ r</code>, <code>let ⟨h₁, h₂, h₃⟩ := h</code> produces the hypotheses
<code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticShow_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L502-L502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticShow_">Lean.Parser.Tactic.tacticShow_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>show t</code> finds the first goal whose target unifies with <code>t</code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code>t</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L503-L505">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.letrec">Lean.Parser.Tactic.letrec</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>let rec f : t := e</code> adds a recursive definition <code>f</code> to the current goal.
The syntax is the same as term-mode <code>let rec</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L510-L510">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_">Lean.Parser.Tactic.tacticRefine_lift'_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>refine_lift</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L512-L512">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_">Lean.Parser.Tactic.tacticHave'_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticHave'_:=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L514-L514">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'_:=_»">Lean.Parser.Tactic.«tacticHave'_:=_»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L516-L516">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_">Lean.Parser.Tactic.tacticLet'_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>let</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAltLHS"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L518-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The left hand side of an induction arm, <code>| foo a b c</code> or <code>| @foo a b c</code>
where <code>foo</code> is a constructor of the inductive type and <code>a b c</code> are the arguments
to the contstructor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L524-L528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>In induction alternative, which can have 1 or more cases on the left
and <code>_</code>, <code>?_</code>, or a tactic sequence after the <code>=></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L529-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>After <code>with</code>, there is an optional tactic that runs on all branches, and
then a list of alternatives.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.induction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L535-L562">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">Lean.Parser.Tactic.induction</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypotheses <code>h : P (Nat.succ a)</code> and <code>ih₁ : P a → Q a</code> and target <code>Q (Nat.succ a)</code>.
Here the names <code>a</code> and <code>ih₁</code> are chosen automatically and are not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e</code>, where <code>e</code> is an expression instead of a variable,
generalizes <code>e</code> in the goal, and then performs induction on the resulting variable.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e using r</code> allows the user to specify the principle of induction that should be used.
Here <code>r</code> should be a theorem whose result type must be of the form <code>C t</code>,
where <code>C</code> is a bound variable and <code>t</code> is a (possibly empty) sequence of bound variables</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e generalizing z₁ ... zₙ</code>, where <code>z₁ ... zₙ</code> are variables in the local context,
generalizes over <code>z₁ ... zₙ</code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</li>
<li>Given <code>x : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x with | zero => tac₁ | succ x' ih => tac₂</code>
uses tactic <code>tac₁</code> for the <code>zero</code> case, and <code>tac₂</code> for the <code>succ</code> case.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalizeArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L564-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a></code> argument, of the form <code>term = x</code> or <code>h : term = x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L567-L574">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">Lean.Parser.Tactic.generalize</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> ([h :] e = x),+</code> replaces all occurrences <code>e</code>s in the main goal
with a fresh hypothesis <code>x</code>s. If <code>h</code> is given, <code>h : e = x</code> is introduced as well.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at h₁ ... hₙ</code> also generalizes occurrences of <code>e</code>
inside <code>h₁</code>, ..., <code>hₙ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at *</code> will generalize occurrences of <code>e</code> everywhere.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.casesTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L576-L580">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> argument, of the form <code>e</code> or <code>h : e</code> (where <code>h</code> asserts that
<code>e = cᵢ a b</code> for each constructor <code>cᵢ</code> of the inductive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.cases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L581-L604">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">Lean.Parser.Tactic.cases</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> x</code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> detects unreachable cases and closes them automatically.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypothesis <code>h : P (Nat.succ a)</code> and target <code>Q (Nat.succ a)</code>.
Here the name <code>a</code> is chosen automatically and is not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then cases on the resulting variable.</li>
<li>Given <code>as : <a href=".././Init/Prelude.html#List">List</a> α</code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> as with | nil => tac₁ | cons a as' => tac₂</code>,
uses tactic <code>tac₁</code> for the <code>nil</code> case, and <code>tac₂</code> for the <code>cons</code> case,
and <code>a</code> and <code>as'</code> are used as names for the new variables introduced.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> h : e</code>, where <code>e</code> is a variable or an expression,
performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each hypothesis,
where <code>...</code> is the constructor instance for that particular case.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.renameI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L606-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.renameI">Lean.Parser.Tactic.renameI</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rename_i x_1 ... x_n</code> renames the last <code>n</code> inaccessible names using the given names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRepeat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L609-L613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_">Lean.Parser.Tactic.tacticRepeat_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>repeat tac</code> applies <code>tac</code> to main goal. If the application succeeds,
the tactic is applied recursively to the generated subgoals until it eventually fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTrivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L617-L625">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code>, ...)
to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) => `(tactic| simp)
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticTrivial</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quottrivial&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L627-L631">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.split">Lean.Parser.Tactic.split</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic is useful for breaking nested if-then-else and match expressions in cases.
For a <code>match</code> expression with <code>n</code> cases, the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic generates at most <code>n</code> subgoals</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L633-L642">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dbgTrace">Lean.Parser.Tactic.dbgTrace</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>dbg_trace "foo"</code> prints <code>foo</code> when elaborated.
Useful for debugging tactic control flow:</p><pre><code>example : <a href=".././Init/Prelude.html#False">False</a> ∨ <a href=".././Init/Prelude.html#True">True</a> := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a>
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inl; trivial; dbg_trace "left"
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inr; trivial; dbg_trace "right"
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticStop_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L650-L650">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticStop_">Lean.Parser.Tactic.tacticStop_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>stop</code> is a helper tactic for "discarding" the rest of a proof:
it is defined as <code>repeat sorry</code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.specialize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L652-L660">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize">Lean.Parser.Tactic.specialize</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize">specialize</a> h a₁ ... aₙ</code> works on local hypothesis <code>h</code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code>a₁</code> ... <code>aₙ</code>.
The tactic adds a new hypothesis with the same name <code>h := h a₁ ... aₙ</code>
and tries to clear the previous one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticUnhygienic_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L681-L681">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_">Lean.Parser.Tactic.tacticUnhygienic_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>unhygienic tacs</code> runs <code>tacs</code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code>unhygienic</code> if possible.</p><pre><code>example : ∀ x : Nat, x = x := by unhygienic
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>            -- x would normally be intro'd as inaccessible
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a> x  -- refer to x
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.fail"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L683-L684">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.fail">Lean.Parser.Tactic.fail</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.fail">fail</a> msg</code> is a tactic that always fails, and produces an error using the given message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.checkpoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L686-L697">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">Lean.Parser.Tactic.checkpoint</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a> tac</code> acts the same as <code>tac</code>, but it caches the input and output of <code>tac</code>,
and if the file is re-elaborated and the input matches, the tactic is not re-run and
its effects are reapplied to the state. This is useful for improving responsiveness
when working on a long tactic proof, by wrapping expensive tactics with <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a></code>.</p><p>See the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> tactic, which may be more convenient to use.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.save"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L709-L709">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> is defined to be the same as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code>, but the elaborator has
special handling for occurrences of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> in tactic scripts and will transform
<code>by tac1; save; tac2</code> to <code>by (checkpoint tac1); tac2</code>, meaning that the effect of <code>tac1</code>
will be cached and replayed. This is useful for improving responsiveness
when working on a long tactic proof, by using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> after expensive tactics.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.save</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotsave&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sleep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L711-L715">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep">Lean.Parser.Tactic.sleep</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep">sleep</a> ms</code> sleeps for <code>ms</code> milliseconds and does nothing.
It is used for debugging purposes only.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticExists_,,»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L721-L722">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»">Lean.Parser.Tactic.«tacticExists_,,»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>exists e₁, e₂, ...</code> is shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> ⟨e₁, e₂, ...⟩; try <a href=".././Init/Core.html#trivial">trivial</a></code>.
It is useful for existential goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.congr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L724-L732">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.congr">Lean.Parser.Tactic.congr</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ <a href=".././Init/Prelude.html#HEq">HEq</a> (f as) (f bs)</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href=".././Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href=".././Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href=".././Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L737-L780">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.simp">Lean.Parser.Attr.simp</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute are by the simplifier
(i.e., the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic, and its variants) to simplify expressions occurring in your goals.
We call theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute "simp theorems" or "simp lemmas".
Lean maintains a database/index containing all active simp theorems.
Here is an example of a simp theorem.</p><pre><code class="language-lean">@[simp] theorem <a href=".././Init/SimpLemmas.html#ne_eq">ne_eq</a> (a b : α) : (a ≠ b) = <a href=".././Init/Prelude.html#Not">Not</a> (a = b) := <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>This simp theorem instructs the simplifier to replace instances of the term
<code>a ≠ b</code> (e.g. <code>x + 0 ≠ y</code>) with <code><a href=".././Init/Prelude.html#Not">Not</a> (a = b)</code> (e.g., <code><a href=".././Init/Prelude.html#Not">Not</a> (x + 0 = y)</code>).
The simplifier applies simp theorems in one direction only:
if <code>A = B</code> is a simp theorem, then <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> replaces <code>A</code>s with <code>B</code>s,
but it doesn't replace <code>B</code>s with <code>A</code>s. Hence a simp theorem should have the
property that its right-hand side is "simpler" than its left-hand side.
In particular, <code>=</code> and <code>↔</code> should not be viewed as symmetric operators in this situation.
The following would be a terrible simp theorem (if it were even allowed):</p><pre><code class="language-lean">@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...
</code></pre><p>Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.
Even worse would be a theorem that causes expressions to grow without bound,
causing simp to loop forever.</p><p>By default the simplifier applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> theorems to an expression <code>e</code>
after its sub-expressions have been simplified.
We say it performs a bottom-up simplification.
You can instruct the simplifier to apply a theorem before its sub-expressions
have been simplified by using the modifier <code>↓</code>. Here is an example</p><pre><code class="language-lean">@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=
</code></pre><p>When multiple simp theorems are applicable, the simplifier uses the one with highest priority.
If there are several with the same priority, it is uses the "most recent one". Example:</p><pre><code class="language-lean">@[simp high] theorem <a href=".././Init/SimpLemmas.html#cond_true">cond_true</a> (a b : α) : <a href=".././Init/Prelude.html#cond">cond</a> true a b = a := <a href=".././Init/Prelude.html#rfl">rfl</a>
@[simp low+1] theorem <a href=".././Init/SimpLemmas.html#or_true">or_true</a> (p : Prop) : (p ∨ True) = <a href=".././Init/Prelude.html#True">True</a> :=
  <a href=".././Init/Core.html#propext">propext</a> <| <a href=".././Init/Core.html#Iff.intro">Iff.intro</a> (fun _ => trivial) (fun _ => <a href=".././Init/Prelude.html#Or.inr">Or.inr</a> trivial)
@[simp 100] theorem <a href=".././Init/SimpLemmas.html#ite_self">ite_self</a> {d : <a href=".././Init/Prelude.html#Decidable">Decidable</a> c} (a : α) : <a href=".././Init/Prelude.html#ite">ite</a> c a a = a := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> d <;> <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="«term‹_›»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L786-L792">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term‹_›»">«term‹_›»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>‹t›</code> resolves to an (arbitrary) hypothesis of type <code>t</code>.
It is useful for referring to hypotheses without accessible names.
<code>t</code> may contain holes that are solved by unification with the expected type;
in particular, <code>‹_›</code> is a shortcut for <code>by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic_trivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L795-L803">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic_trivial">tacticGet_elem_tactic_trivial</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic_trivial</code> is an extensible tactic automatically called
by the notation <code>arr[i]</code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to just try <code><a href=".././Init/Core.html#trivial">trivial</a></code> (which handles the case
where <code>i < arr.size</code> is in the context) and <code>simp_arith</code>
(for doing linear arithmetic in the index).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#tacticGet_elem_tactic_trivial">tacticGet_elem_tactic_trivial</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticGet_elem_tactic_trivial</span> <span class="fn">1024</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotget_elem_tactic_trivial&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L815-L823">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic">tacticGet_elem_tactic</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic</code> is the tactic automatically called by the notation <code>arr[i]</code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code>get_elem_tactic_trivial</code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code>get_elem_tactic_trivial</code> instead of this tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#tacticGet_elem_tactic">tacticGet_elem_tactic</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticGet_elem_tactic</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotget_elem_tactic&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="«term__[_]»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L825-L826">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term__[_]»">«term__[_]»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The syntax <code>arr[i]</code> gets the <code>i</code>'th element of the collection <code>arr</code>.
If there are proof side conditions to the application, they will be automatically
inferred by the <code>get_elem_tactic</code> tactic.</p><p>The actual behavior of this class is type-dependent,
but here are some important implementations:</p><ul>
<li><code>arr[i] : α</code> where <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code>i : <a href=".././Init/Prelude.html#USize">USize</a></code>:
does array indexing with no bounds check and a proof side goal <code>i < arr.size</code>.</li>
<li><code>l[i] : α</code> where <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: index into a list,
with proof side goal <code>i < l.length</code>.</li>
<li><code>stx[i] : Syntax</code> where <code>stx : Syntax</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: get a syntax argument,
no side goal (returns <code>.missing</code> out of range)</li>
</ul><p>There are other variations on this syntax:</p><ul>
<li><code>arr[i]</code>: proves the proof side goal by <code>get_elem_tactic</code></li>
<li><code>arr[i]!</code>: panics if the side goal is false</li>
<li><code>arr[i]?</code>: returns <code>none</code> if the side goal is false</li>
<li><code>arr[i]'h</code>: uses <code>h</code> to prove the side goal</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="«term__[_]'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Tactics.lean#L829-L830">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term__[_]'_»">«term__[_]'_»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The syntax <code>arr[i]</code> gets the <code>i</code>'th element of the collection <code>arr</code>.
If there are proof side conditions to the application, they will be automatically
inferred by the <code>get_elem_tactic</code> tactic.</p><p>The actual behavior of this class is type-dependent,
but here are some important implementations:</p><ul>
<li><code>arr[i] : α</code> where <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code>i : <a href=".././Init/Prelude.html#USize">USize</a></code>:
does array indexing with no bounds check and a proof side goal <code>i < arr.size</code>.</li>
<li><code>l[i] : α</code> where <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: index into a list,
with proof side goal <code>i < l.length</code>.</li>
<li><code>stx[i] : Syntax</code> where <code>stx : Syntax</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: get a syntax argument,
no side goal (returns <code>.missing</code> out of range)</li>
</ul><p>There are other variations on this syntax:</p><ul>
<li><code>arr[i]</code>: proves the proof side goal by <code>get_elem_tactic</code></li>
<li><code>arr[i]!</code>: panics if the side goal is false</li>
<li><code>arr[i]?</code>: returns <code>none</code> if the side goal is false</li>
<li><code>arr[i]'h</code>: uses <code>h</code> to prove the side goal</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././/navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>