{"name":"Lean.Compiler.LCNF.Simp.Main","instances":[],"imports":["Init","Lean.Compiler.ImplementedByAttr","Lean.Compiler.LCNF.ElimDead","Lean.Compiler.LCNF.AlphaEqv","Lean.Compiler.LCNF.PrettyPrinter","Lean.Compiler.LCNF.Bind","Lean.Compiler.LCNF.Simp.FunDeclInfo","Lean.Compiler.LCNF.Simp.InlineCandidate","Lean.Compiler.LCNF.Simp.InlineProj","Lean.Compiler.LCNF.Simp.Used","Lean.Compiler.LCNF.Simp.DefaultAlt","Lean.Compiler.LCNF.Simp.SimpValue","Lean.Compiler.LCNF.Simp.ConstantFold"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L218-L332","name":"Lean.Compiler.LCNF.Simp.simp","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.simp","doc":"Simplify `code`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L187-L213","name":"Lean.Compiler.LCNF.Simp.simpCasesOnCtor?","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.simpCasesOnCtor?","doc":"Try to simplify `cases` of `constructor`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L178-L182","name":"Lean.Compiler.LCNF.Simp.simpFunDecl","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.simpFunDecl","doc":"Simplify the given local function declaration.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L120-L173","name":"Lean.Compiler.LCNF.Simp.inlineApp?","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.inlineApp?","doc":"If the value of the given let-declaration is an application that can be inlined,\ninline it and simplify the result.\n\n`k` is the \"continuation\" for the let declaration, if the application is inlined,\nit will also be simplified.\n\nNote: `inlineApp?` did not use to be in this mutually recursive declaration.\nIt used to be invoked by `simp`, and would return `Option Code` that would be\nthen simplified by `simp`. However, this simpler architecture produced an\nexponential blowup in when processing functions such as `Lean.Elab.Deriving.Ord.mkMatch.mkAlts`.\nThe key problem is that when inlining a declaration we often can reduce the number\nof exit points by simplified the inlined code, and then connecting the result to the\ncontinuation `k`. However, this optimization is only possible if we simplify the\ninlined code **before** we attach it to the continuation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L99-L101","name":"Lean.Compiler.LCNF.Simp.elimVar?","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.elimVar?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L94-L97","name":"Lean.Compiler.LCNF.Simp.isReturnOf","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.isReturnOf","doc":"Similar to `Code.isReturnOf`, but taking the current substitution into account.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L74-L89","name":"Lean.Compiler.LCNF.Simp.etaPolyApp?","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.etaPolyApp?","doc":"When the configuration flag `etaPoly = true`, we eta-expand\npartial applications of functions that take local instances as arguments.\nThis kind of function is inlined or specialized, and we create new\nsimplification opportunities by eta-expanding them.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L62-L66","name":"Lean.Compiler.LCNF.Simp.inlineJp?","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.inlineJp?","doc":"Try to inline a join point.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/Main.lean#L45-L57","name":"Lean.Compiler.LCNF.Simp.specializePartialApp","docLink":"./Lean/Compiler/LCNF/Simp/Main.html#Lean.Compiler.LCNF.Simp.specializePartialApp","doc":"Create a new local function declaration when `info.args.size < info.params.size`.\nWe use this function to inline/specialize a partial application of a local function.\n"}]}