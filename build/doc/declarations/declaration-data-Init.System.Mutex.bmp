{"name":"Init.System.Mutex","instances":[{"typeNames":["IO.BaseMutex"],"name":"IO.instNonemptyBaseMutex","className":"Nonempty"},{"typeNames":["IO.Condvar"],"name":"IO.instNonemptyCondvar","className":"Nonempty"},{"typeNames":["IO.Mutex"],"name":"IO.instNonemptyMutex","className":"Nonempty"},{"typeNames":["IO.Mutex","IO.BaseMutex"],"name":"IO.instCoeMutexBaseMutex","className":"Coe"}],"imports":["Init.System.IO","Init.Control.StateRef"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L117-L123","name":"IO.Mutex.atomicallyOnce","docLink":"./Init/System/Mutex.html#IO.Mutex.atomicallyOnce","doc":"`mutex.atomicallyOnce condvar pred k` runs `k`,\nwaiting on `condvar` until `pred` returns true.\nBoth `k` and `pred` have access to the mutex's state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L104-L110","name":"IO.Mutex.atomically","docLink":"./Init/System/Mutex.html#IO.Mutex.atomically","doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L101-L101","name":"IO.AtomicT","docLink":"./Init/System/Mutex.html#IO.AtomicT","doc":"`AtomicT α m` is the monad that can be atomically executed inside a `Mutex α`,\nwith outside monad `m`.\nThe action has access to the state `α` of the mutex (via `get` and `set`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L93-L94","name":"IO.Mutex.new","docLink":"./Init/System/Mutex.html#IO.Mutex.new","doc":"Creates a new mutex. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L90-L90","name":"IO.instCoeMutexBaseMutex","docLink":"./Init/System/Mutex.html#IO.instCoeMutexBaseMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L85-L88","name":"IO.instNonemptyMutex","docLink":"./Init/System/Mutex.html#IO.instNonemptyMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L81-L83","name":"IO.Mutex","docLink":"./Init/System/Mutex.html#IO.Mutex","doc":"Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`,\nexcept that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L69-L72","name":"IO.Condvar.waitUntil","docLink":"./Init/System/Mutex.html#IO.Condvar.waitUntil","doc":"Waits on the condition variable until the predicate is true. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L66-L66","name":"IO.Condvar.notifyAll","docLink":"./Init/System/Mutex.html#IO.Condvar.notifyAll","doc":"Wakes up all other threads executing `wait`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L62-L62","name":"IO.Condvar.notifyOne","docLink":"./Init/System/Mutex.html#IO.Condvar.notifyOne","doc":"Wakes up a single other thread executing `wait`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L58-L58","name":"IO.Condvar.wait","docLink":"./Init/System/Mutex.html#IO.Condvar.wait","doc":"Waits until another thread calls `notifyOne` or `notifyAll`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L54-L54","name":"IO.Condvar.new","docLink":"./Init/System/Mutex.html#IO.Condvar.new","doc":"Creates a new condition variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L50-L50","name":"IO.instNonemptyCondvar","docLink":"./Init/System/Mutex.html#IO.instNonemptyCondvar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L48-L48","name":"IO.Condvar","docLink":"./Init/System/Mutex.html#IO.Condvar","doc":"Condition variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L43-L43","name":"IO.BaseMutex.unlock","docLink":"./Init/System/Mutex.html#IO.BaseMutex.unlock","doc":"Unlocks a `BaseMutex`.\n\nThe current thread must have already locked the mutex.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L34-L34","name":"IO.BaseMutex.lock","docLink":"./Init/System/Mutex.html#IO.BaseMutex.lock","doc":"Locks a `BaseMutex`.  Waits until no other thread has locked the mutex.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L25-L25","name":"IO.BaseMutex.new","docLink":"./Init/System/Mutex.html#IO.BaseMutex.new","doc":"Creates a new `BaseMutex`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L21-L21","name":"IO.instNonemptyBaseMutex","docLink":"./Init/System/Mutex.html#IO.instNonemptyBaseMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/System/Mutex.lean#L19-L19","name":"IO.BaseMutex","docLink":"./Init/System/Mutex.html#IO.BaseMutex","doc":"Mutual exclusion primitive (a lock).\n\nIf you want to guard shared state, use `Mutex α` instead.\n"}]}