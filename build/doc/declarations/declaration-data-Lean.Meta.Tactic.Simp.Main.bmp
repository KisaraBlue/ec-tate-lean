{"name":"Lean.Meta.Tactic.Simp.Main","instances":[{"typeNames":["Lean.Meta.Simp.M"],"name":"Lean.Meta.Simp.instInhabitedM","className":"Inhabited"}],"imports":["Init","Lean.Meta.Transform","Lean.Meta.Tactic.Replace","Lean.Meta.Tactic.UnifyEq","Lean.Meta.Tactic.Simp.Rewrite"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L990-L1019","name":"Lean.Meta.dsimpGoal","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.dsimpGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L974-L988","name":"Lean.Meta.simpTargetStar","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTargetStar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L938-L972","name":"Lean.Meta.simpGoal","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L930-L936","name":"Lean.Meta.simpLocalDecl","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpLocalDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L918-L928","name":"Lean.Meta.applySimpResultToLocalDecl","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToLocalDecl","doc":"Simplify `simp` result to the given local declaration. Return `none` if the goal was closed.\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L902-L913","name":"Lean.Meta.applySimpResultToLocalDeclCore","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToLocalDeclCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L897-L900","name":"Lean.Meta.simpStep","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpStep","doc":"Simplify `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\notherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L888-L890","name":"Lean.Meta.applySimpResultToFVarId","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L873-L886","name":"Lean.Meta.applySimpResultToProp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToProp","doc":"Apply the result `r` for `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\notherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L862-L866","name":"Lean.Meta.simpTarget","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTarget","doc":"Simplify the given goal target (aka type). Return `none` if the goal was closed. Return `some mvarId'` otherwise,\nwhere `mvarId'` is the simplified new goal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L847-L857","name":"Lean.Meta.simpTargetCore","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTargetCore","doc":"See `simpTarget`. This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L837-L844","name":"Lean.Meta.applySimpResultToTarget","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToTarget","doc":"Auxiliary method.\nGiven the current `target` of `mvarId`, apply `r` which is a new target and proof that it is equal to the current one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L829-L831","name":"Lean.Meta.dsimp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.dsimp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L823-L827","name":"Lean.Meta.simp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L815-L816","name":"Lean.Meta.Simp.DefaultMethods.methods","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.methods","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L811-L812","name":"Lean.Meta.Simp.DefaultMethods.post","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.post","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L808-L809","name":"Lean.Meta.Simp.DefaultMethods.pre","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.pre","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L786-L806","name":"Lean.Meta.Simp.DefaultMethods.discharge?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.discharge?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L769-L782","name":"Lean.Meta.Simp.dischargeEqnThmHypothesis?.go?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeEqnThmHypothesis?.go?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L760-L782","name":"Lean.Meta.Simp.dischargeEqnThmHypothesis?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeEqnThmHypothesis?","doc":"Tries to solve `e` using `unifyEq?`.\nIt assumes that `isEqnThmHypothesis e` is `true`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L747-L754","name":"Lean.Meta.Simp.dischargeUsingAssumption?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeUsingAssumption?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L745-L745","name":"Lean.Meta.Simp.Discharge","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Discharge","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L740-L743","name":"Lean.Meta.Simp.isEqnThmHypothesis.go","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isEqnThmHypothesis.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L737-L743","name":"Lean.Meta.Simp.isEqnThmHypothesis","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isEqnThmHypothesis","doc":"Return true if `e` is of the form `(x : α) → ... → s = t → ... → False`\n\nRecall that this kind of proposition is generated by Lean when creating equations for\nfunctions and match-expressions with overlapping cases.\nExample: the following `match`-expression has overlapping cases.\n```\ndef f (x y : Nat) :=\n  match x, y with\n  | Nat.succ n, Nat.succ m => ...\n  | _, _ => 0\n```\nThe second equation is of the form\n```\n(x y : Nat) → ((n m : Nat) → x = Nat.succ n → y = Nat.succ m → False) → f x y = 0\n```\nThe hypothesis `(n m : Nat) → x = Nat.succ n → y = Nat.succ m → False` is essentially\nsaying the first case is not applicable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L710-L716","name":"Lean.Meta.Simp.dsimpMain","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dsimpMain","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L701-L708","name":"Lean.Meta.Simp.main","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.main","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L695-L699","name":"Lean.Meta.Simp.simp.cacheResult","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.cacheResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L663-L693","name":"Lean.Meta.Simp.simp.simpLet","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L648-L661","name":"Lean.Meta.Simp.simp.simpForall","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L613-L646","name":"Lean.Meta.Simp.simp.simpArrow","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L602-L611","name":"Lean.Meta.Simp.simp.simpLambda","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L587-L600","name":"Lean.Meta.Simp.simp.withNewLemmas","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.withNewLemmas","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L584-L585","name":"Lean.Meta.Simp.simp.simpConst","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpConst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L574-L582","name":"Lean.Meta.Simp.simp.simpApp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L561-L572","name":"Lean.Meta.Simp.simp.congr","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L516-L559","name":"Lean.Meta.Simp.simp.trySimpCongrTheorem?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.trySimpCongrTheorem?","doc":"Try to rewrite `e` children using the given congruence theorem "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L482-L513","name":"Lean.Meta.Simp.simp.processCongrHypothesis","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.processCongrHypothesis","doc":"Process the given congruence theorem hypothesis. Return true if it made \"progress\". "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L474-L479","name":"Lean.Meta.Simp.simp.congrDefault","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congrDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L385-L472","name":"Lean.Meta.Simp.simp.tryAutoCongrTheorem?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.tryAutoCongrTheorem?","doc":"Try to use automatically generated congruence theorems. See `mkCongrSimp?`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L367-L382","name":"Lean.Meta.Simp.simp.mkCongrSimp?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.mkCongrSimp?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L353-L365","name":"Lean.Meta.Simp.simp.visitFn","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.visitFn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L335-L351","name":"Lean.Meta.Simp.simp.congrArgs","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congrArgs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L309-L333","name":"Lean.Meta.Simp.simp.simpProj","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpProj","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L298-L307","name":"Lean.Meta.Simp.simp.simpLit","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L283-L296","name":"Lean.Meta.Simp.simp.simpStep","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpStep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L262-L281","name":"Lean.Meta.Simp.simp.simpLoop","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLoop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L246-L699","name":"Lean.Meta.Simp.simp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L240-L244","name":"Lean.Meta.Simp.removeUnnecessaryCasts.elimDummyEqRec","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts.elimDummyEqRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L237-L238","name":"Lean.Meta.Simp.removeUnnecessaryCasts.isDummyEqRec","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts.isDummyEqRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L224-L244","name":"Lean.Meta.Simp.removeUnnecessaryCasts","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts","doc":"Given the application `e`, remove unnecessary casts of the form `Eq.rec a rfl` and `Eq.ndrec a rfl`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L209-L221","name":"Lean.Meta.Simp.getSimpLetCase","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.getSimpLetCase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L204-L207","name":"Lean.Meta.Simp.SimpLetCase","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.SimpLetCase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L199-L202","name":"Lean.Meta.Simp.lambdaTelescopeDSimp.go","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.lambdaTelescopeDSimp.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L196-L202","name":"Lean.Meta.Simp.lambdaTelescopeDSimp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.lambdaTelescopeDSimp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L193-L194","name":"Lean.Meta.Simp.instInhabitedM","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.instInhabitedM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L72-L73","name":"Lean.Meta.Simp.isOfNatNatLit","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isOfNatNatLit","doc":"Return true if `e` is of the form `ofNat n` where `n` is a kernel Nat literal "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L57-L63","name":"Lean.Meta.Simp.mkCongr","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.mkCongr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L52-L55","name":"Lean.Meta.Simp.mkCongrFun","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.mkCongrFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L41-L50","name":"Lean.Meta.Simp.Result.getProof'","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Result.getProof'","doc":"Similar to `Result.getProof`, but adds a `mkExpectedTypeHint` if `proof?` is `none`\n(i.e., result is definitionally equal to input), but we cannot establish that\n`source` and `r.expr` are definitionally when using `TransparencyMode.reducible`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L32-L35","name":"Lean.Meta.Simp.Result.getProof","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Result.getProof","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L23-L30","name":"Lean.Meta.Simp.Config.updateArith","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Config.updateArith","doc":"Helper method for bootstrapping purposes. It disables `arith` if support theorems have not been defined yet.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L17-L18","name":"Lean.Meta.Simp.throwCongrHypothesisFailed","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.throwCongrHypothesisFailed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Tactic/Simp/Main.lean#L14-L15","name":"Lean.Meta.Simp.congrHypothesisExceptionId","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.congrHypothesisExceptionId","doc":""}]}