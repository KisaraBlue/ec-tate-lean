{"name":"Lean.Meta.Transform","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L162-L163","name":"Lean.Meta.erasePatternRefAnnotations","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L159-L160","name":"Lean.Meta.eraseInaccessibleAnnotations","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L140-L157","name":"Lean.Meta.unfoldDeclsFrom","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L125-L137","name":"Lean.Meta.zetaReduce","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L101-L106","name":"Lean.Meta.transform.visit.visitLet","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L95-L100","name":"Lean.Meta.transform.visit.visitForall","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L89-L94","name":"Lean.Meta.transform.visit.visitLambda","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L84-L88","name":"Lean.Meta.transform.visit.visitPost","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L82-L122","name":"Lean.Meta.transform.visit","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L74-L123","name":"Lean.Meta.transform","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L64-L65","name":"Lean.Core.betaReduce","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L44-L48","name":"Lean.Core.transform.visit.visitPost","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L42-L61","name":"Lean.Core.transform.visit","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L35-L62","name":"Lean.Core.transform","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","doc":"Transform the expression `input` using `pre` and `post`.\n- First `pre` is invoked with the current expression and recursion is continued according to the `TransformStep` result.\n  In all cases, the expression contained in the result, if any, must be definitionally equal to the current expression.\n- After recursion, if any, `post` is invoked on the resulting expression.\n\nThe term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\nif one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\nConsider using `Meta.transform` to avoid loose bound variables.\n\nThis method is useful for applying transformations such as beta-reduction and delta-reduction.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Transform.lean#L10-L19","name":"Lean.TransformStep","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","doc":""}]}