{"name":"Lean.Compiler.LCNF.Simp.JpCases","instances":[{"typeNames":["Lean.Compiler.LCNF.Simp.JpCasesInfo"],"name":"Lean.Compiler.LCNF.Simp.instInhabitedJpCasesInfo","className":"Inhabited"}],"imports":["Init","Lean.Compiler.LCNF.DependsOn","Lean.Compiler.LCNF.InferType","Lean.Compiler.LCNF.Internalize","Lean.Compiler.LCNF.Simp.Basic","Lean.Compiler.LCNF.Simp.DiscrM"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L273-L293","name":"Lean.Compiler.LCNF.Simp.simpJpCases?.visitJmp?","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.simpJpCases?.visitJmp?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L232-L271","name":"Lean.Compiler.LCNF.Simp.simpJpCases?.visitJp?","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.simpJpCases?.visitJp?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L204-L230","name":"Lean.Compiler.LCNF.Simp.simpJpCases?.visit","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.simpJpCases?.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L194-L293","name":"Lean.Compiler.LCNF.Simp.simpJpCases?","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.simpJpCases?","doc":"Try to optimize `jpCases` join points.\nWe say a join point is a `jpCases` when it satifies the predicate `isJpCases`.\nIf we have a jump to `jpCases` with a constructor, then we can optimize the code by creating an new join point for\nthe constructor.\nExample: suppose we have\n```lean\njp _jp.1 y :=\n  let x.1 := true\n  cases y\n  | nil => let x.2 := g x.1; return x.2\n  | cons h t => let x.3 := h x.1; return x.3\n...\ncases x.4\n| ctor1 =>\n  let x.5 := cons z.1 z.2\n  jmp _jp.1 x.5\n| ctor2 =>\n  let x.6 := f x.4\n  jmp _jp.1 x.6\n```\nThis `simpJpCases?` converts it to\n```lean\njp _jp.2 h t :=\n  let x.1 := true\n  let x.3 := h x.1\n  return x.3\njp _jp.1 y :=\n  let x.1 := true\n  cases y\n  | nil => let x.2 := g x.1; return x.2\n  | cons h t => jmp _jp.2 h t\n...\ncases x.4\n| ctor1 =>\n  -- The constructor has been eliminated here\n  jmp _jp.2 z.1 z.2\n| ctor2 =>\n  let x.6 := f x.4\n  jmp _jp.1 x.6\n```\nNote that if all jumps to the join point are with constructors,\nthen the join point is eliminated as dead code.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L104-L104","name":"Lean.Compiler.LCNF.Simp.Ctor2JpCasesAlt","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.Ctor2JpCasesAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L99-L102","name":"Lean.Compiler.LCNF.Simp.JpCasesAlt","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.JpCasesAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L68-L85","name":"Lean.Compiler.LCNF.Simp.collectJpCasesInfo.go","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.collectJpCasesInfo.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L64-L85","name":"Lean.Compiler.LCNF.Simp.collectJpCasesInfo","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.collectJpCasesInfo","doc":"Return a map containing entries `jpFVarId â†¦ { paramIdx, ctorNames }` where `jpFVarId` is the id of join point\nin code that satisfies `isJpCases`, and `ctorNames` is a set of constructor names such that\nthere is a jump `.jmp jpFVarId #[..., x, ...]` in `code` and `x` is a constructor application.\n`paramIdx` is the index of the parameter\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L55-L56","name":"Lean.Compiler.LCNF.Simp.JpCasesInfoMap.isCandidate","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.JpCasesInfoMap.isCandidate","doc":"Return `true` if the collected information suggests opportunities for the `JpCases` optimization. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L52-L52","name":"Lean.Compiler.LCNF.Simp.JpCasesInfoMap","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.JpCasesInfoMap","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L50-L50","name":"Lean.Compiler.LCNF.Simp.instInhabitedJpCasesInfo","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.instInhabitedJpCasesInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L42-L50","name":"Lean.Compiler.LCNF.Simp.JpCasesInfo","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.JpCasesInfo","doc":"Information for join points that satisfy `isJpCases?`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L31-L36","name":"Lean.Compiler.LCNF.Simp.isJpCases?.go","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.isJpCases?.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/JpCases.lean#L26-L37","name":"Lean.Compiler.LCNF.Simp.isJpCases?","docLink":"./Lean/Compiler/LCNF/Simp/JpCases.html#Lean.Compiler.LCNF.Simp.isJpCases?","doc":"Given the function declaration `decl`, return `some idx` if it is of the form\n```\nf y :=\n  ... /- This part is not bigger than smallThreshold. -/\n  cases y\n  | ... => ...\n  ...\n```\n`idx` is the index of the parameter used in the `cases` statement.\n"}]}