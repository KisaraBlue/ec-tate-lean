{"name":"Lean.ResolveName","instances":[{"typeNames":[],"name":"Lean.instMonadResolveName","className":"Lean.MonadResolveName"}],"imports":["Init","Lean.Data.OpenDecl","Lean.Hygiene","Lean.Modifiers","Lean.Exception"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L326-L336","name":"Lean.unresolveNameGlobal.unresolveNameCore","docLink":"./Lean/ResolveName.html#Lean.unresolveNameGlobal.unresolveNameCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L312-L336","name":"Lean.unresolveNameGlobal","docLink":"./Lean/ResolveName.html#Lean.unresolveNameGlobal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L306-L310","name":"Lean.resolveGlobalConstNoOverload","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstNoOverload","doc":"Interpret the syntax `n` as an identifier for a global constant, and return a resolved\nconstant name. If there are multiple possible interpretations it will throw.\n\n## Example:\n```\ndef Boo.x   := 1\ndef Foo.x   := 2\ndef Foo.x.y := 3\n```\nAfter `open Foo`, we have\n- `resolveGlobalConstNoOverload x`     => `Foo.x`\n- `resolveGlobalConstNoOverload x.y`   => `Foo.x.y`\n- `resolveGlobalConstNoOverload x.z.w` => error: unknown constant\n\nAfter `open Foo open Boo`, we have\n- `resolveGlobalConstNoOverload x`     => error: ambiguous identifier\n- `resolveGlobalConstNoOverload x.y`   => `Foo.x.y`\n- `resolveGlobalConstNoOverload x.z.w` => error: unknown constant\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L276-L285","name":"Lean.resolveGlobalConst","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConst","doc":"Interpret the syntax `n` as an identifier for a global constant, and return a list of resolved\nconstant names that it could be refering to based on the currently open namespaces.\nThis should be used instead of `resolveGlobalConstCore` for identifiers taken from syntax\nbecause `Syntax` objects may have names that have already been resolved.\n\n## Example:\n```\ndef Boo.x   := 1\ndef Foo.x   := 2\ndef Foo.x.y := 3\n```\nAfter `open Foo`, we have\n- `resolveGlobalConst x`     => `[Foo.x]`\n- `resolveGlobalConst x.y`   => `[Foo.x.y]`\n- `resolveGlobalConst x.z.w` => error: unknown constant\n\nAfter `open Foo open Boo`, we have\n- `resolveGlobalConst x`     => `[Foo.x, Boo.x]`\n- `resolveGlobalConst x.y`   => `[Foo.x.y]`\n- `resolveGlobalConst x.z.w` => error: unknown constant\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L249-L253","name":"Lean.resolveGlobalConstNoOverloadCore","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstNoOverloadCore","doc":"For identifiers taken from syntax, use `resolveGlobalConstNoOverload` instead, which respects preresolved names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L242-L246","name":"Lean.resolveGlobalConstCore","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstCore","doc":"Given a name `n`, return a list of possible interpretations for global constants.\n\nSimilar to `resolveGlobalName`, but discard any candidate whose `fieldList` is not empty.\nFor identifiers taken from syntax, use `resolveGlobalConst` instead, which respects preresolved names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L233-L236","name":"Lean.resolveUniqueNamespace","docLink":"./Lean/ResolveName.html#Lean.resolveUniqueNamespace","doc":"Given a namespace identifier, return the unique interpretation or else fail. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L221-L230","name":"Lean.resolveNamespace","docLink":"./Lean/ResolveName.html#Lean.resolveNamespace","doc":"Given a namespace identifier, return a list of possible interpretations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L214-L218","name":"Lean.resolveNamespaceCore","docLink":"./Lean/ResolveName.html#Lean.resolveNamespaceCore","doc":"Given a namespace name, return a list of possible interpretations.\nNames extracted from syntax should be passed to `resolveNamespace` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L207-L208","name":"Lean.resolveGlobalName","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalName","doc":"Given a name `n`, return a list of possible interpretations.\nEach interpretation is a pair `(declName, fieldList)`, where `declName`\nis the name of a declaration in the current environment, and `fieldList` are\n(potential) field names.\nThe pair is needed because in Lean `.` may be part of a qualified name or\na field (aka dot-notation).\nAs an example, consider the following definitions\n```\ndef Boo.x   := 1\ndef Foo.x   := 2\ndef Foo.x.y := 3\n```\nAfter `open Foo`, we have\n- `resolveGlobalName x`     => `[(Foo.x, [])]`\n- `resolveGlobalName x.y`   => `[(Foo.x.y, [])]`\n- `resolveGlobalName x.z.w` => `[(Foo.x, [z, w])]`\n\nAfter `open Foo open Boo`, we have\n- `resolveGlobalName x`     => `[(Foo.x, []), (Boo.x, [])]`\n- `resolveGlobalName x.y`   => `[(Foo.x.y, [])]`\n- `resolveGlobalName x.z.w` => `[(Foo.x, [z, w]), (Boo.x, [z, w])]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L180-L182","name":"Lean.instMonadResolveName","docLink":"./Lean/ResolveName.html#Lean.instMonadResolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L174-L176","name":"Lean.MonadResolveName","docLink":"./Lean/ResolveName.html#Lean.MonadResolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L167-L170","name":"Lean.ResolveName.resolveNamespace","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespace","doc":"Given a name `id` try to find namespaces it may refer to. The resolution procedure works as follows\n\n1- If `id` is in the scope of `namespace` commands the namespace `s_1. ... . s_n`,\nthen we include `s_1 . ... . s_i ++ n` in the result if it is the name of an existing namespace.\nWe search \"backwards\", and include at most one of the in the list of resulting namespaces.\n\n2- If `id` is the extact name of an existing namespace, then include `id`\n\n3- Finally, for each command `open N`, include in the result `N ++ n` if it is the name of an existing namespace.\nWe only consider simple `open` commands. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L147-L154","name":"Lean.ResolveName.resolveNamespaceUsingOpenDecls","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespaceUsingOpenDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L142-L145","name":"Lean.ResolveName.resolveNamespaceUsingScope?","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespaceUsingScope?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L118-L137","name":"Lean.ResolveName.resolveGlobalName.loop","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveGlobalName.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L115-L138","name":"Lean.ResolveName.resolveGlobalName","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveGlobalName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L52-L53","name":"Lean.getRevAliases","docLink":"./Lean/ResolveName.html#Lean.getRevAliases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L42-L49","name":"Lean.getAliases","docLink":"./Lean/ResolveName.html#Lean.getAliases","doc":"Retrieve aliases for `a`. If `skipProtected` is `true`, then the resulting list only includes\ndeclarations that are not marked as `proctected`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L35-L36","name":"Lean.getAliasState","docLink":"./Lean/ResolveName.html#Lean.getAliasState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L32-L33","name":"Lean.addAlias","docLink":"./Lean/ResolveName.html#Lean.addAlias","doc":"Add alias `a` for `e` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L25-L29","name":"Lean.aliasExtension","docLink":"./Lean/ResolveName.html#Lean.aliasExtension","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L20-L23","name":"Lean.addAliasEntry","docLink":"./Lean/ResolveName.html#Lean.addAliasEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L18-L18","name":"Lean.AliasEntry","docLink":"./Lean/ResolveName.html#Lean.AliasEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/ResolveName.lean#L17-L17","name":"Lean.AliasState","docLink":"./Lean/ResolveName.html#Lean.AliasState","doc":""}]}