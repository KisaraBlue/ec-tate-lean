{"name":"Lean.Elab.Syntax","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Parser.Syntax","Lean.Elab.Util"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L420-L423","name":"Lean.Elab.Command.strLitToPattern","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.strLitToPattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L405-L418","name":"Lean.Elab.Command.expandNoKindMacroRulesAux","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.expandNoKindMacroRulesAux","doc":"Infer syntax kind `k` from first pattern, put alternatives of same kind into new `macro/elab_rules (kind := k)` via `mkCmd (some k)`,\nleave remaining alternatives (via `mkCmd none`) to be recursively expanded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L394-L400","name":"Lean.Elab.Command.inferMacroRulesAltKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.inferMacroRulesAltKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L391-L392","name":"Lean.Elab.Command.checkRuleKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.checkRuleKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L383-L389","name":"Lean.Elab.Command.elabSyntaxAbbrev","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntaxAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L348-L381","name":"Lean.Elab.Command.elabSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L343-L346","name":"Lean.Elab.Command.resolveSyntaxKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.resolveSyntaxKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L319-L322","name":"Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L305-L317","name":"Lean.Elab.Command.mkNameFromParserSyntax.visit","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L302-L322","name":"Lean.Elab.Command.mkNameFromParserSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax","doc":"Auxiliary function for creating declaration names from parser descriptions.\nExample:\nGiven\n```\nsyntax term \"+\" term : term\nsyntax \"[\" sepBy(term, \", \") \"]\"  : term\n```\nIt generates the names `term_+_` and `term[_,]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L275-L290","name":"Lean.Elab.Command.elabDeclareSyntaxCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabDeclareSyntaxCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L249-L251","name":"Lean.Elab.Term.toParserDescr.processNonReserved","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNonReserved","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L236-L247","name":"Lean.Elab.Term.toParserDescr.processAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L229-L234","name":"Lean.Elab.Term.toParserDescr.isValidAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.isValidAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L222-L227","name":"Lean.Elab.Term.toParserDescr.processSepBy1","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L215-L220","name":"Lean.Elab.Term.toParserDescr.processSepBy","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L193-L213","name":"Lean.Elab.Term.toParserDescr.processNullaryOrCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNullaryOrCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L161-L191","name":"Lean.Elab.Term.toParserDescr.processAlias","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAlias","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L153-L159","name":"Lean.Elab.Term.toParserDescr.processParserCategory","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processParserCategory","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L149-L151","name":"Lean.Elab.Term.toParserDescr.ensureNoPrec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.ensureNoPrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L138-L147","name":"Lean.Elab.Term.toParserDescr.processSeq","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSeq","doc":"Sequence (aka NullNode) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L109-L135","name":"Lean.Elab.Term.toParserDescr.process","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L103-L251","name":"Lean.Elab.Term.toParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr","doc":"Given a `stx` of category `syntax`, return a `(newStx, lhsPrec?)`,\nwhere `newStx` is of category `term`. After elaboration, `newStx` should have type\n`TrailingParserDescr` if `lhsPrec?.isSome`, and `ParserDescr` otherwise. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L93-L96","name":"Lean.Elab.Term.elabParserName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.elabParserName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L82-L91","name":"Lean.Elab.Term.elabParserName?","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.elabParserName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L68-L80","name":"Lean.Elab.Term.checkLeftRec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.checkLeftRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L63-L66","name":"Lean.Elab.Term.addAliasInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addAliasInfo","doc":"(Try to) add a term info for the alias with info `info` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L57-L60","name":"Lean.Elab.Term.addCategoryInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addCategoryInfo","doc":"(Try to) add a term info for the category `catName` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L46-L51","name":"Lean.Elab.Term.ensureUnaryOutput","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ensureUnaryOutput","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L40-L40","name":"Lean.Elab.Term.ToParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L39-L39","name":"Lean.Elab.Term.ToParserDescrM","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L32-L37","name":"Lean.Elab.Term.ToParserDescrContext","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Syntax.lean#L14-L18","name":"Lean.Elab.Term.expandOptPrecedence","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.expandOptPrecedence","doc":"Expand `optional «precedence»` where\n«precedence» := leading_parser \" : \" >> precedenceParser "}]}