{"name":"Lean.Elab.Syntax","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Parser.Syntax","Lean.Elab.Util"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L408-L411","name":"Lean.Elab.Command.strLitToPattern","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.strLitToPattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L393-L406","name":"Lean.Elab.Command.expandNoKindMacroRulesAux","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.expandNoKindMacroRulesAux","doc":"Infer syntax kind `k` from first pattern, put alternatives of same kind into new `macro/elab_rules (kind := k)` via `mkCmd (some k)`,\nleave remaining alternatives (via `mkCmd none`) to be recursively expanded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L382-L388","name":"Lean.Elab.Command.inferMacroRulesAltKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.inferMacroRulesAltKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L379-L380","name":"Lean.Elab.Command.checkRuleKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.checkRuleKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L371-L377","name":"Lean.Elab.Command.elabSyntaxAbbrev","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntaxAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L336-L369","name":"Lean.Elab.Command.elabSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L331-L334","name":"Lean.Elab.Command.resolveSyntaxKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.resolveSyntaxKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L307-L310","name":"Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L293-L305","name":"Lean.Elab.Command.mkNameFromParserSyntax.visit","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L290-L310","name":"Lean.Elab.Command.mkNameFromParserSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax","doc":"Auxiliary function for creating declaration names from parser descriptions.\nExample:\nGiven\n```\nsyntax term \"+\" term : term\nsyntax \"[\" sepBy(term, \", \") \"]\"  : term\n```\nIt generates the names `term_+_` and `term[_,]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L263-L278","name":"Lean.Elab.Command.elabDeclareSyntaxCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabDeclareSyntaxCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L237-L239","name":"Lean.Elab.Term.toParserDescr.processNonReserved","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNonReserved","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L224-L235","name":"Lean.Elab.Term.toParserDescr.processAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L217-L222","name":"Lean.Elab.Term.toParserDescr.isValidAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.isValidAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L210-L215","name":"Lean.Elab.Term.toParserDescr.processSepBy1","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L203-L208","name":"Lean.Elab.Term.toParserDescr.processSepBy","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L181-L201","name":"Lean.Elab.Term.toParserDescr.processNullaryOrCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNullaryOrCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L161-L179","name":"Lean.Elab.Term.toParserDescr.processAlias","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAlias","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L153-L159","name":"Lean.Elab.Term.toParserDescr.processParserCategory","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processParserCategory","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L149-L151","name":"Lean.Elab.Term.toParserDescr.ensureNoPrec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.ensureNoPrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L138-L147","name":"Lean.Elab.Term.toParserDescr.processSeq","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSeq","doc":"Sequence (aka NullNode) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L109-L135","name":"Lean.Elab.Term.toParserDescr.process","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L103-L239","name":"Lean.Elab.Term.toParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr","doc":"Given a `stx` of category `syntax`, return a `(newStx, lhsPrec?)`,\nwhere `newStx` is of category `term`. After elaboration, `newStx` should have type\n`TrailingParserDescr` if `lhsPrec?.isSome`, and `ParserDescr` otherwise. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L93-L96","name":"Lean.Elab.Term.elabParserName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.elabParserName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L82-L91","name":"Lean.Elab.Term.elabParserName?","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.elabParserName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L68-L80","name":"Lean.Elab.Term.checkLeftRec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.checkLeftRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L63-L66","name":"Lean.Elab.Term.addAliasInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addAliasInfo","doc":"(Try to) add a term info for the alias with info `info` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L57-L60","name":"Lean.Elab.Term.addCategoryInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addCategoryInfo","doc":"(Try to) add a term info for the category `catName` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L46-L51","name":"Lean.Elab.Term.ensureUnaryOutput","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ensureUnaryOutput","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L40-L40","name":"Lean.Elab.Term.ToParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L39-L39","name":"Lean.Elab.Term.ToParserDescrM","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L32-L37","name":"Lean.Elab.Term.ToParserDescrContext","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Syntax.lean#L14-L18","name":"Lean.Elab.Term.expandOptPrecedence","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.expandOptPrecedence","doc":"Expand `optional «precedence»` where\n«precedence» := leading_parser \" : \" >> precedenceParser "}]}