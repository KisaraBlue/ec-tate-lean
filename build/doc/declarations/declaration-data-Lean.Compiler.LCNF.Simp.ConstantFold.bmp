{"name":"Lean.Compiler.LCNF.Simp.ConstantFold","instances":[{"typeNames":["Nat"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["String"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt8"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt16"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt32"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt64"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["Char"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"}],"imports":["Init","Lean.Compiler.LCNF.CompilerM","Lean.Compiler.LCNF.InferType","Lean.Compiler.LCNF.PassManager"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L402-L403","name":"Lean.Compiler.LCNF.Simp.ConstantFold.foldConstants","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.foldConstants","doc":"Apply a list of default folders to `decl`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L396-L397","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getFolders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L392-L394","name":"Lean.Compiler.LCNF.Simp.ConstantFold.registerFolder","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.registerFolder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L377-L390","name":"Lean.Compiler.LCNF.Simp.ConstantFold.folderExt","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.folderExt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L374-L375","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L370-L372","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L366-L368","name":"Lean.Compiler.LCNF.Simp.ConstantFold.builtinFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.builtinFolders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L346-L355","name":"Lean.Compiler.LCNF.Simp.ConstantFold.applyFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.applyFolders","doc":"Apply all known folders to `decl`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L337-L341","name":"Lean.Compiler.LCNF.Simp.ConstantFold.stringFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.stringFolders","doc":"All string folders.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L310-L332","name":"Lean.Compiler.LCNF.Simp.ConstantFold.arithmeticFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.arithmeticFolders","doc":"All arithmetic folders.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L303-L305","name":"Lean.Compiler.LCNF.Simp.ConstantFold.higherOrderLiteralFolders","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.higherOrderLiteralFolders","doc":"Literal folders for higher order datastructures.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L297-L298","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightAnnihilator","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightAnnihilator","doc":"Provide a folder for an operation that has the same left and right annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L291-L292","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightNeutral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightNeutral","doc":"Provide a folder for an operation that has the same left and right neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L279-L286","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.first","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.first","doc":"Pick the first folder out of `folders` that succeeds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L268-L274","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightAnnihilator","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightAnnihilator","doc":"Provide a folder for an operation with a right annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L257-L263","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftAnnihilator","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftAnnihilator","doc":"Provide a folder for an operation with a left annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L245-L252","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightNeutral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightNeutral","doc":"Provide a folder for an operation with a right neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L233-L240","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftNeutral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftNeutral","doc":"Provide a folder for an operation with a left neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L220-L228","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinary","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinary","doc":"Turn a binary function such as `Nat.add` into a constant folder.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L209-L215","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkUnary","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkUnary","doc":"Turn a unary function such as `Nat.succ` into a constant folder.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L197-L204","name":"Lean.Compiler.LCNF.Simp.ConstantFold.foldArrayLiteral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.foldArrayLiteral","doc":"Evaluate array literals at compile time, that is turn:\n```\nlet _x.1 := @List.nil _\nlet _x.2 := @List.cons _ z _x.1\nlet _x.3 := @List.cons _ y _x.2\nlet _x.4 := @List.cons _ x _x.3\nlet _x.5 := @List.toArray _ _x.4\n```\nTo its array form:\n```\nlet _x.12 := 3\nlet _x.8 := @Array.mkEmpty _ _x.12\nlet _x.22 := @Array.push _ _x.8 x\nlet _x.24 := @Array.push _ _x.22 y\nlet _x.26 := @Array.push _ _x.24 z\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L172-L177","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkPseudoArrayLiteral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkPseudoArrayLiteral","doc":"Turn an `#[a, b, c]` into:\n```\nlet _x.12 := 3\nlet _x.8 := @Array.mkEmpty _ _x.12\nlet _x.22 := @Array.push _ _x.8 x\nlet _x.24 := @Array.push _ _x.22 y\nlet _x.26 := @Array.push _ _x.24 z\n_x.26\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L143-L159","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral.go","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L140-L159","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral","doc":"Turns an expression chain of the form\n```\nlet _x.1 := @List.nil _\nlet _x.2 := @List.cons _ a _x.1\nlet _x.3 := @List.cons _ b _x.2\nlet _x.4 := @List.cons _ c _x.3\nlet _x.5 := @List.cons _ d _x.4\nlet _x.6 := @List.cons _ e _x.5\n```\ninto: `[a, b, c, d ,e]` + The type contained in the list\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L124-L124","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L123-L123","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L122-L122","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L121-L121","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L120-L120","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L114-L118","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkNatWrapperInstance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkNatWrapperInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L93-L95","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L90-L91","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkStringLit","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkStringLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L82-L88","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getStringLit","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getStringLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L78-L80","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L75-L76","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkNatLit","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkNatLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L65-L73","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getNatLit","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getNatLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L61-L63","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLit","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLit","doc":"A wrapper around `mkAuxLetDecl` that also calls `mkLit`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L51-L54","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLetDecl","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLetDecl","doc":"A wrapper around `LCNF.mkAuxLetDecl` that will automaticaly store the\n`LetDecl` in the state of `FolderM`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L31-L43","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Literal","doc":"A typeclass for detecting and producing literals of arbitrary types\ninside of LCNF.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L25-L25","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder","doc":"A constant folder for a specific function, takes all the arguments of a\ncertain function and produces a new `Expr` + auxiliary declarations in\nthe `FolderM` monad on success. If the folding fails it returns `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L18-L18","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderM","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderM","doc":"A constant folding monad, the additional state stores auxiliary declarations\nrequired to build the new constant.\n"}]}