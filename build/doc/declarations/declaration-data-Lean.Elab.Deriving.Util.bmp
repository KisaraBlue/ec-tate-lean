{"name":"Lean.Elab.Deriving.Util","instances":[],"imports":["Init","Lean.Parser.Term","Lean.Elab.Term"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L151-L156","name":"Lean.Elab.Deriving.mkDiscrs","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkDiscrs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L135-L149","name":"Lean.Elab.Deriving.mkHeader","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkHeader","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L128-L132","name":"Lean.Elab.Deriving.Header","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L125-L126","name":"Lean.Elab.Deriving.mkDiscr","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L109-L123","name":"Lean.Elab.Deriving.mkInstanceCmds","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkInstanceCmds","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L104-L106","name":"Lean.Elab.Deriving.mkLet","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L86-L102","name":"Lean.Elab.Deriving.mkLocalInstanceLetDecls","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkLocalInstanceLetDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L68-L84","name":"Lean.Elab.Deriving.mkContext","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L63-L66","name":"Lean.Elab.Deriving.Context","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L48-L61","name":"Lean.Elab.Deriving.mkInstImplicitBinders","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkInstImplicitBinders","doc":"Return instance binder syntaxes binding `className α` for every generic parameter `α`\nof the inductive `indVal` for which such a binding is type-correct. `argNames` is expected\nto provide names for the parameters (see `mkInductArgNames`). The output matches `instBinder*`.\n\nFor example, given `inductive Foo {α : Type} (n : Nat) : (β : Type) → Type`, where `β` is an index,\ninvoking ``mkInstImplicitBinders `BarClass foo #[`α, `n, `β]`` gives `` `([BarClass α])``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L38-L40","name":"Lean.Elab.Deriving.mkImplicitBinders","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkImplicitBinders","doc":"Return implicit binder syntaxes for the given `argNames`. The output matches `implicitBinder*`.\n\nFor example, ``#[`foo,`bar]`` gives `` `({foo} {bar})``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L29-L32","name":"Lean.Elab.Deriving.mkInductiveApp","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkInductiveApp","doc":"Return the inductive declaration's type applied to the arguments in `argNames`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L19-L26","name":"Lean.Elab.Deriving.mkInductArgNames","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.mkInductArgNames","doc":"Make fresh, hygienic names for every parameter and index of an inductive declaration.\n\nFor example, `inductive Foo {α : Type} : Nat → Type` will give something like ``#[`α✝, `a✝]``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L14-L14","name":"Lean.Elab.Deriving.explicitBinderF","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.explicitBinderF","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L13-L13","name":"Lean.Elab.Deriving.instBinderF","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.instBinderF","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Elab/Deriving/Util.lean#L12-L12","name":"Lean.Elab.Deriving.implicitBinderF","docLink":"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.implicitBinderF","doc":""}]}