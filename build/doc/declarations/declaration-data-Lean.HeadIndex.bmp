{"name":"Lean.HeadIndex","instances":[{"typeNames":["Lean.HeadIndex"],"name":"Lean.instInhabitedHeadIndex","className":"Inhabited"},{"typeNames":["Lean.HeadIndex"],"name":"Lean.instBEqHeadIndex","className":"BEq"},{"typeNames":["Lean.HeadIndex"],"name":"Lean.instReprHeadIndex","className":"Repr"},{"typeNames":["Lean.HeadIndex"],"name":"Lean.HeadIndex.instHashableHeadIndex","className":"Hashable"}],"imports":["Init","Lean.Expr"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L108-L111","name":"Lean.Expr.toHeadIndex","docLink":"./Lean/HeadIndex.html#Lean.Expr.toHeadIndex","doc":"Convert the given expression into a `HeadIndex`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L57-L61","name":"Lean.Expr.headNumArgs.go","docLink":"./Lean/HeadIndex.html#Lean.Expr.headNumArgs.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L54-L61","name":"Lean.Expr.headNumArgs","docLink":"./Lean/HeadIndex.html#Lean.Expr.headNumArgs","doc":"Return the number of arguments in the given expression with respect to its `HeadIndex` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L47-L47","name":"Lean.HeadIndex.instHashableHeadIndex","docLink":"./Lean/HeadIndex.html#Lean.HeadIndex.instHashableHeadIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L37-L45","name":"Lean.HeadIndex.HeadIndex.hash","docLink":"./Lean/HeadIndex.html#Lean.HeadIndex.HeadIndex.hash","doc":"Hash code for a `HeadIndex` value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L32-L32","name":"Lean.instReprHeadIndex","docLink":"./Lean/HeadIndex.html#Lean.instReprHeadIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L32-L32","name":"Lean.instBEqHeadIndex","docLink":"./Lean/HeadIndex.html#Lean.instBEqHeadIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L32-L32","name":"Lean.instInhabitedHeadIndex","docLink":"./Lean/HeadIndex.html#Lean.instInhabitedHeadIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/HeadIndex.lean#L23-L32","name":"Lean.HeadIndex","docLink":"./Lean/HeadIndex.html#Lean.HeadIndex","doc":"Datastructure for representing the \"head symbol\" of an expression.\nIt is the key of `KExprMap`.\nExamples:\n- The head of `f a` is `.const f`\n- The head of `let x := 1; f x` is `.const f`\n- The head of `fun x => fun` is `.lam`\n\n`HeadIndex` is a very simple index, and is used in situations where\nwe want to find definitionally equal terms, but we want to minimize\nthe search by checking only pairs of terms that have the same\n`HeadIndex`.\n"}]}