{"name":"Lean.Meta.AppBuilder","instances":[],"imports":["Init","Lean.Structure","Lean.Util.Recognizers","Lean.Meta.SynthInstance","Lean.Meta.Check","Lean.Meta.DecLevel"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L593-L597","name":"Lean.Meta.mkIffOfEq","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkIffOfEq","doc":"Given `h : a = b`, return a proof for `a ↔ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L590-L590","name":"Lean.Meta.mkLT","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLT","doc":"Return `a < b`. This method assumes `a` and `b` have the same type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L587-L587","name":"Lean.Meta.mkLE","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLE","doc":"Return `a ≤ b`. This method assumes `a` and `b` have the same type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L572-L572","name":"Lean.Meta.mkMul","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkMul","doc":"Return `a * b` using a heterogeneous `*`. This method assumes `a` and `b` have the same type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L569-L569","name":"Lean.Meta.mkSub","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkSub","doc":"Return `a - b` using a heterogeneous `-`. This method assumes `a` and `b` have the same type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L566-L566","name":"Lean.Meta.mkAdd","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAdd","doc":"Return `a + b` using a heterogeneous `+`. This method assumes `a` and `b` have the same type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L548-L551","name":"Lean.Meta.mkNumeral","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkNumeral","doc":"Return `(n : type)`, a numeric literal of type `type`. The method fails if we don't have an instance `OfNat type n` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L537-L545","name":"Lean.Meta.isMonad?","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.isMonad?","doc":"Return instance for `[Monad m]` if there is one "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L533-L534","name":"Lean.Meta.mkForallCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkForallCongr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L530-L531","name":"Lean.Meta.mkImpDepCongrCtx","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkImpDepCongrCtx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L527-L528","name":"Lean.Meta.mkImpCongrCtx","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkImpCongrCtx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L524-L525","name":"Lean.Meta.mkImpCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkImpCongr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L521-L522","name":"Lean.Meta.mkEqFalse'","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqFalse'","doc":"Return `eq_false' h`\n`h` must have type definitionally equal to `p → False` in the current\nreducibility setting. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L514-L515","name":"Lean.Meta.mkEqFalse","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqFalse","doc":"Return `eq_false h`\n`h` must have type definitionally equal to `¬ p` in the current\nreducibility setting. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L507-L508","name":"Lean.Meta.mkEqTrue","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqTrue","doc":"Return `eq_true h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L503-L504","name":"Lean.Meta.mkOfEqTrue","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkOfEqTrue","doc":"Return `of_eq_true h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L499-L500","name":"Lean.Meta.mkLetBodyCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLetBodyCongr","doc":"Return `let_body_congr a h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L495-L496","name":"Lean.Meta.mkLetValCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLetValCongr","doc":"Return `let_val_congr b h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L491-L492","name":"Lean.Meta.mkLetCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLetCongr","doc":"Return `let_congr h₁ h₂` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L487-L488","name":"Lean.Meta.mkPropExt","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkPropExt","doc":"Return `propext h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L483-L484","name":"Lean.Meta.mkFunExt","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkFunExt","doc":"Return `funext h` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L479-L480","name":"Lean.Meta.mkSyntheticSorry","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkSyntheticSorry","doc":"Return `sorryAx type` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L475-L476","name":"Lean.Meta.mkOfNonempty","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkOfNonempty","doc":"Return `@Classical.ofNonempty α _` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L471-L472","name":"Lean.Meta.mkDefault","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkDefault","doc":"Return `Inhabited.default α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L467-L468","name":"Lean.Meta.mkLe","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLe","doc":"Return `a <= b` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L463-L464","name":"Lean.Meta.mkLt","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkLt","doc":"Return `a < b` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L455-L460","name":"Lean.Meta.mkDecideProof","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkDecideProof","doc":"Return a proof for `p : Prop` using `decide p` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L451-L452","name":"Lean.Meta.mkDecide","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkDecide","doc":"Return `Decidable.decide p` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L446-L448","name":"Lean.Meta.mkSorry","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkSorry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L441-L444","name":"Lean.Meta.mkArrayLit","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkArrayLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L432-L439","name":"Lean.Meta.mkListLit","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkListLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L401-L426","name":"Lean.Meta.mkProjection","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkProjection","doc":"`mkProjection s fieldName` return an expression for accessing field `fieldName` of the structure `s`.\nRemark: `fieldName` may be a subfield of `s`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L395-L396","name":"Lean.Meta.mkPure","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkPure","doc":"Given a `monad` and `e : α`, makes `pure e`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L383-L392","name":"Lean.Meta.mkNoConfusion","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkNoConfusion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L380-L381","name":"Lean.Meta.mkEqMPR","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqMPR","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L377-L378","name":"Lean.Meta.mkEqMP","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqMP","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L361-L375","name":"Lean.Meta.mkEqRec","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L346-L359","name":"Lean.Meta.mkEqNDRec","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqNDRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L341-L344","name":"Lean.Meta.mkAppOptM'","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAppOptM'","doc":"Similar to `mkAppOptM`, but takes an `Expr` instead of a constant name "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L335-L338","name":"Lean.Meta.mkAppOptM","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAppOptM","doc":"Similar to `mkAppM`, but it allows us to specify which arguments are provided explicitly using `Option` type.\nExample:\nGiven `Pure.pure {m : Type u → Type v} [Pure m] {α : Type u} (a : α) : m α`,\n```\nmkAppOptM `Pure.pure #[m, none, none, a]\n```\nreturns a `Pure.pure` application if the instance `Pure m` can be synthesized, and the universe match.\nNote that,\n```\nmkAppM `Pure.pure #[a]\n```\nfails because the only explicit argument `(a : α)` is not sufficient for inferring the remaining arguments,\nwe would need the expected type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L284-L287","name":"Lean.Meta.mkAppM'","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAppM'","doc":"Similar to `mkAppM`, but takes an `Expr` instead of a constant name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L278-L281","name":"Lean.Meta.mkAppM","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAppM","doc":"Return the application `constName xs`.\nIt tries to fill the implicit arguments before the last element in `xs`.\n\nRemark:\n``mkAppM `arbitrary #[α]`` returns `@arbitrary.{u} α` without synthesizing\nthe implicit argument occurring after `α`.\nGiven a `x : (([Decidable p] → Bool) × Nat`, ``mkAppM `Prod.fst #[x]`` returns `@Prod.fst ([Decidable p] → Bool) Nat x`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L188-L206","name":"Lean.Meta.mkCongr","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkCongr","doc":"Given `h₁ : f = g` and `h₂ : a = b`, returns a proof of `f a = g b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L170-L185","name":"Lean.Meta.mkCongrFun","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkCongrFun","doc":"Given `h : f = g` and `a : α`, returns a proof of `f a = g a`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L155-L167","name":"Lean.Meta.mkCongrArg","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkCongrArg","doc":"Given `f : α → β` and `h : a = b`, returns a proof of `f a = f b`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L143-L152","name":"Lean.Meta.mkEqOfHEq","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqOfHEq","doc":"Given `h : Eq a b`, returns a proof of `HEq a b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L127-L140","name":"Lean.Meta.mkHEqTrans","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkHEqTrans","doc":"Given `h₁ : HEq a b`, `h₂ : HEq b c`, returns a proof of `HEq a c`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L114-L124","name":"Lean.Meta.mkHEqSymm","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkHEqSymm","doc":"Given `h : HEq a b`, returns a proof of `HEq b a`.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L98-L111","name":"Lean.Meta.mkEqTrans","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqTrans","doc":"Given `h₁ : a = b` and `h₂ : b = c` returns a proof of `a = c`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L86-L95","name":"Lean.Meta.mkEqSymm","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqSymm","doc":"Given `h : a = b`, returns a proof of `b = a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L71-L73","name":"Lean.Meta.mkFalseElim","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkFalseElim","doc":"Given `h : False`, return an instance of type `e`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L65-L68","name":"Lean.Meta.mkAbsurd","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkAbsurd","doc":"Given `hp : P` and `nhp : Not P` returns an instance of type `e`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L59-L62","name":"Lean.Meta.mkHEqRefl","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkHEqRefl","doc":"Return a proof of `HEq a a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L53-L56","name":"Lean.Meta.mkEqRefl","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqRefl","doc":"Return a proof of `a = a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L43-L50","name":"Lean.Meta.mkEqHEq","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEqHEq","doc":"If `a` and `b` have definitionally equal types, return `Eq a b`, otherwise return `HEq a b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L34-L38","name":"Lean.Meta.mkHEq","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkHEq","doc":"Return `HEq a b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L28-L31","name":"Lean.Meta.mkEq","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkEq","doc":"Return `a = b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L23-L25","name":"Lean.Meta.mkExpectedTypeHint","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkExpectedTypeHint","doc":"Given `e` s.t. `inferType e` is definitionally equal to `expectedType`, return\nterm `@id expectedType e`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/AppBuilder.lean#L15-L18","name":"Lean.Meta.mkId","docLink":"./Lean/Meta/AppBuilder.html#Lean.Meta.mkId","doc":"Return `id e` "}]}