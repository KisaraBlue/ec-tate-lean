{"name":"Lean.Compiler.LCNF.FixedParams","instances":[{"typeNames":["Lean.Compiler.LCNF.FixedParams.Value"],"name":"Lean.Compiler.LCNF.FixedParams.instInhabitedValue","className":"Inhabited"},{"typeNames":["Lean.Compiler.LCNF.FixedParams.Value"],"name":"Lean.Compiler.LCNF.FixedParams.instBEqValue","className":"BEq"},{"typeNames":["Lean.Compiler.LCNF.FixedParams.Value"],"name":"Lean.Compiler.LCNF.FixedParams.instHashableValue","className":"Hashable"}],"imports":["Init","Lean.Compiler.LCNF.Basic","Lean.Compiler.LCNF.Types"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L165-L173","name":"Lean.Compiler.LCNF.mkFixedParamsMap","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.mkFixedParamsMap","doc":"Given the (potentially mutually) recursive declarations `decls`,\nreturn a map from declaration name `decl.name` to a bit-mask `m` where `m[i]` is true\niff the `decl.params[i]` is a fixed argument. That is, it does not change in recursive\napplications.\nThe function assumes that if a function `f` was declared in a mutual block, then `decls`\ncontains all (computationally relevant) functions in the mutual block.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L148-L152","name":"Lean.Compiler.LCNF.FixedParams.mkInitialValues","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.mkInitialValues","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L113-L144","name":"Lean.Compiler.LCNF.FixedParams.evalApp","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.evalApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L106-L111","name":"Lean.Compiler.LCNF.FixedParams.evalCode","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.evalCode","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L97-L104","name":"Lean.Compiler.LCNF.FixedParams.evalExpr","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.evalExpr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L89-L93","name":"Lean.Compiler.LCNF.FixedParams.mkAssignment","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.mkAssignment","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L86-L87","name":"Lean.Compiler.LCNF.FixedParams.inMutualBlock","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.inMutualBlock","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L79-L84","name":"Lean.Compiler.LCNF.FixedParams.evalArg","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.evalArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L75-L77","name":"Lean.Compiler.LCNF.FixedParams.abort","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.abort","doc":"Stop the analysis and mark all parameters as non-fixed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L72-L72","name":"Lean.Compiler.LCNF.FixedParams.FixParamM","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.FixParamM","doc":"Monad for the fixed parameter static analyzer. We use the unit-exception to interrupt the analysis. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L57-L69","name":"Lean.Compiler.LCNF.FixedParams.State","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L43-L55","name":"Lean.Compiler.LCNF.FixedParams.Context","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L41-L41","name":"Lean.Compiler.LCNF.FixedParams.instHashableValue","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.instHashableValue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L41-L41","name":"Lean.Compiler.LCNF.FixedParams.instBEqValue","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.instBEqValue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L41-L41","name":"Lean.Compiler.LCNF.FixedParams.instInhabitedValue","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.instInhabitedValue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/FixedParams.lean#L37-L41","name":"Lean.Compiler.LCNF.FixedParams.Value","docLink":"./Lean/Compiler/LCNF/FixedParams.html#Lean.Compiler.LCNF.FixedParams.Value","doc":"Abstract value for the \"fixed parameter\" analysis. "}]}