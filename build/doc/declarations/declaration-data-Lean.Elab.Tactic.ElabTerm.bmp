{"name":"Lean.Elab.Tactic.ElabTerm","instances":[],"imports":["Init","Lean.Meta.Tactic.Constructor","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Clear","Lean.Meta.Tactic.Rename","Lean.Elab.Tactic.Basic","Lean.Elab.SyntheticMVars"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L364-L371","name":"Lean.Elab.Tactic.evalNativeDecide","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalNativeDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L341-L351","name":"Lean.Elab.Tactic.evalDecide","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L312-L327","name":"Lean.Elab.Tactic.evalRename","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRename","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L294-L310","name":"Lean.Elab.Tactic.elabAsFVar","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabAsFVar","doc":"Elaborate `stx`. If it a free variable, return it. Otherwise, assert it, and return the free variable.\nNote that, the main goal is updated when `Meta.assert` is used in the second case. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L288-L289","name":"Lean.Elab.Tactic.evalWithUnfoldingAll","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L285-L286","name":"Lean.Elab.Tactic.evalWithReducibleAndInstances","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducibleAndInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L282-L283","name":"Lean.Elab.Tactic.evalWithReducible","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L276-L280","name":"Lean.Elab.Tactic.evalConstructor","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalConstructor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L271-L274","name":"Lean.Elab.Tactic.evalApply","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L251-L269","name":"Lean.Elab.Tactic.evalApplyLikeTactic","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApplyLikeTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L248-L249","name":"Lean.Elab.Tactic.getFVarIds","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarIds","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L240-L246","name":"Lean.Elab.Tactic.getFVarId","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L200-L238","name":"Lean.Elab.Tactic.elabTermForApply","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermForApply","doc":"Given a tactic\n```\napply f\n```\nwe want the `apply` tactic to create all metavariables. The following\ndefinition will return `@f` for `f`. That is, it will **not** create\nmetavariables for implicit arguments.\nA similar method is also used in Lean 3.\nThis method is useful when applying lemmas such as:\n```\ntheorem infLeRight {s t : Set α} : s ⊓ t ≤ t\n```\nwhere `s ≤ t` here is defined as\n```\n∀ {x : α}, x ∈ s → x ∈ t\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L167-L180","name":"Lean.Elab.Tactic.evalSpecialize","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalSpecialize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L162-L165","name":"Lean.Elab.Tactic.evalRefine'","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L157-L160","name":"Lean.Elab.Tactic.evalRefine","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L146-L155","name":"Lean.Elab.Tactic.refineCore","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.refineCore","doc":"If `allowNaturalHoles == true`, then we allow the resultant expression to contain unassigned \"natural\" metavariables.\nRecall that \"natutal\" metavariables are created for explicit holes `_` and implicit arguments. They are meant to be\nfilled by typing constraints.\n\"Synthetic\" metavariables are meant to be filled by tactics and are usually created using the synthetic hole notation `?<hole-name>`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L139-L140","name":"Lean.Elab.Tactic.elabTermWithHoles","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermWithHoles","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L115-L137","name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom.go","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L86-L137","name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom","doc":"Execute `k`, and collect new \"holes\" in the resulting expression.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L80-L81","name":"Lean.Elab.Tactic.sortMVarIdsByIndex","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdsByIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L70-L78","name":"Lean.Elab.Tactic.sortMVarIdArrayByIndex","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdArrayByIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L61-L68","name":"Lean.Elab.Tactic.evalExact","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalExact","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L57-L59","name":"Lean.Elab.Tactic.filterOldMVars","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.filterOldMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L53-L55","name":"Lean.Elab.Tactic.logUnassignedAndAbort","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.logUnassignedAndAbort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L49-L51","name":"Lean.Elab.Tactic.closeMainGoalUsing","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.closeMainGoalUsing","doc":"Try to close main goal using `x target`, where `target` is the type of the main goal.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L35-L46","name":"Lean.Elab.Tactic.elabTermEnsuringType","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermEnsuringType","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration and then a `TypeMismatchError` will be thrown if the elaborated type doesn't match.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L27-L31","name":"Lean.Elab.Tactic.elabTerm.go","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/ElabTerm.lean#L20-L31","name":"Lean.Elab.Tactic.elabTerm","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration but not enforced (use `elabTermEnsuringType` to enforce an expected type). "}]}