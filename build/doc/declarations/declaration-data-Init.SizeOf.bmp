{"name":"Init.SizeOf","instances":[{"typeNames":[],"name":"instSizeOf","className":"SizeOf"},{"typeNames":["Nat"],"name":"instSizeOfNat","className":"SizeOf"},{"typeNames":["Unit"],"name":"instSizeOfForAllUnit","className":"SizeOf"},{"typeNames":["Lean.Name"],"name":"Lean.instSizeOfName","className":"SizeOf"}],"imports":["Init.Tactics"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L106-L107","name":"Lean.Name.num.sizeOf_spec","docLink":"./Init/SizeOf.html#Lean.Name.num.sizeOf_spec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L104-L105","name":"Lean.Name.str.sizeOf_spec","docLink":"./Init/SizeOf.html#Lean.Name.str.sizeOf_spec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L102-L103","name":"Lean.Name.anonymous.sizeOf_spec","docLink":"./Init/SizeOf.html#Lean.Name.anonymous.sizeOf_spec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L99-L100","name":"Lean.instSizeOfName","docLink":"./Init/SizeOf.html#Lean.instSizeOfName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L94-L97","name":"Lean.Name.sizeOf","docLink":"./Init/SizeOf.html#Lean.Name.sizeOf","doc":"We manually define the `Lean.Name` instance because we use\nan opaque function for computing the hashcode field.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L86-L86","name":"Bool.sizeOf_eq_one","docLink":"./Init/SizeOf.html#Bool.sizeOf_eq_one","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L85-L85","name":"Unit.sizeOf","docLink":"./Init/SizeOf.html#Unit.sizeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L57-L58","name":"sizeOf_thunk","docLink":"./Init/SizeOf.html#sizeOf_thunk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L54-L55","name":"instSizeOfForAllUnit","docLink":"./Init/SizeOf.html#instSizeOfForAllUnit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L52-L52","name":"sizeOf_nat","docLink":"./Init/SizeOf.html#sizeOf_nat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L49-L50","name":"instSizeOfNat","docLink":"./Init/SizeOf.html#instSizeOfNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L47-L47","name":"sizeOf_default","docLink":"./Init/SizeOf.html#sizeOf_default","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L44-L45","name":"instSizeOf","docLink":"./Init/SizeOf.html#instSizeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L41-L42","name":"default.sizeOf","docLink":"./Init/SizeOf.html#default.sizeOf","doc":"Every type `α` has a default `SizeOf` instance that just returns `0`\nfor every element of `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/SizeOf.lean#L25-L28","name":"SizeOf","docLink":"./Init/SizeOf.html#SizeOf","doc":"`SizeOf` is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to `Nat`.\nThe default instance defines each constructor to be `1` plus the sum of the\nsizes of all the constructor fields.\n\nThis is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the `termination_by` argument on the function definition.\n"}]}