{"name":"Lean.Elab.Tactic.Induction","instances":[{"typeNames":["Lean.Elab.Tactic.ElimApp.Alt"],"name":"Lean.Elab.Tactic.ElimApp.instInhabitedAlt","className":"Inhabited"}],"imports":["Init","Lean.Util.CollectFVars","Lean.AuxRecursor","Lean.Parser.Term","Lean.Meta.RecursorInfo","Lean.Meta.CollectMVars","Lean.Meta.Tactic.ElimInfo","Lean.Meta.Tactic.Induction","Lean.Meta.Tactic.Cases","Lean.Meta.GeneralizeVars","Lean.Elab.App","Lean.Elab.Tactic.ElabTerm","Lean.Elab.Tactic.Generalize"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L590-L616","name":"Lean.Elab.Tactic.evalCases","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalCases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L568-L588","name":"Lean.Elab.Tactic.elabCasesTargets","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.elabCasesTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L560-L566","name":"Lean.Elab.Tactic.evalInduction.checkTargets","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction.checkTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L531-L566","name":"Lean.Elab.Tactic.evalInduction","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L487-L493","name":"Lean.Elab.Tactic.getInductiveValFromMajor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.getInductiveValFromMajor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L356-L360","name":"Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L278-L355","name":"Lean.Elab.Tactic.ElimApp.evalAlts.go","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L264-L360","name":"Lean.Elab.Tactic.ElimApp.evalAlts","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L251-L262","name":"Lean.Elab.Tactic.ElimApp.reorderAlts","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.reorderAlts","doc":"If `altsSyntax` is not empty we reorder `alts` using the order the alternatives have been provided\nin `altsSyntax`. Motivations:\n\n1- It improves the effectiveness of the `checkpoint` and `save` tactics. Consider the following example:\n```lean\nexample (h₁ : p ∨ q) (h₂ : p → x = 0) (h₃ : q → y = 0) : x * y = 0 := by\n  cases h₁ with\n  | inr h =>\n    sleep 5000 -- sleeps for 5 seconds\n    save\n    have : y = 0 := h₃ h\n    -- We can confortably work here\n  | inl h => stop ...\n```\nIf we do reorder, the `inl` alternative will be executed first. Moreover, as we type in the `inr` alternative,\ntype errors will \"swallow\" the `inl` alternative and affect the tactic state at `save` making it ineffective.\n\n2- The errors are produced in the same order the appear in the code above. This is not super important when using IDEs.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L186-L193","name":"Lean.Elab.Tactic.ElimApp.setMotiveArg","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.setMotiveArg","doc":"Given a goal `... targets ... |- C[targets]` associated with `mvarId`, assign\n`motiveArg := fun targets => C[targets]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L130-L168","name":"Lean.Elab.Tactic.ElimApp.mkElimApp.loop","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L129-L182","name":"Lean.Elab.Tactic.ElimApp.mkElimApp","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp","doc":"Construct the an eliminator/recursor application. `targets` contains the explicit and implicit targets for\nthe eliminator. For example, the indices of builtin recursors are considered implicit targets.\nRemark: the method `addImplicitTargets` may be used to compute the sequence of implicit and explicit targets\nfrom the explicit ones.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L118-L121","name":"Lean.Elab.Tactic.ElimApp.Result","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L103-L103","name":"Lean.Elab.Tactic.ElimApp.M","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L95-L101","name":"Lean.Elab.Tactic.ElimApp.State","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L91-L93","name":"Lean.Elab.Tactic.ElimApp.Context","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L89-L89","name":"Lean.Elab.Tactic.ElimApp.instInhabitedAlt","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.instInhabitedAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L79-L89","name":"Lean.Elab.Tactic.ElimApp.Alt","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L56-L72","name":"Lean.Elab.Tactic.evalAlt","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Tactic/Induction.lean#L53-L54","name":"Lean.Elab.Tactic.isHoleRHS","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.isHoleRHS","doc":""}]}