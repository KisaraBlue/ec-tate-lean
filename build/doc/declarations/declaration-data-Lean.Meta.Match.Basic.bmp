{"name":"Lean.Meta.Match.Basic","instances":[{"typeNames":["Lean.Meta.Match.Pattern"],"name":"Lean.Meta.Match.instInhabitedPattern","className":"Inhabited"},{"typeNames":["Lean.Meta.Match.Alt"],"name":"Lean.Meta.Match.instInhabitedAlt","className":"Inhabited"},{"typeNames":["Lean.Meta.Match.Problem"],"name":"Lean.Meta.Match.instInhabitedProblem","className":"Inhabited"}],"imports":["Init","Lean.Meta.Check","Lean.Meta.CollectFVars","Lean.Meta.Match.MatcherInfo","Lean.Meta.Match.CaseArraySizes"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L328-L356","name":"Lean.Meta.Match.toPattern","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.toPattern","doc":"Convert a expression occurring as the argument of a `match` motive application back into a `Pattern`\nFor example, we can use this method to convert `x::y::xs` at\n```\n...\n(motive : List Nat → Sort u_1) (xs : List Nat) (h_1 : (x y : Nat) → (xs : List Nat) → motive (x :: y :: xs))\n...\n```\ninto a pattern object\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L312-L316","name":"Lean.Meta.Match.MatcherResult","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.MatcherResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L309-L310","name":"Lean.Meta.Match.counterExamplesToMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.counterExamplesToMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L306-L307","name":"Lean.Meta.Match.counterExampleToMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.counterExampleToMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L304-L304","name":"Lean.Meta.Match.CounterExample","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.CounterExample","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L298-L302","name":"Lean.Meta.Match.Problem.toMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Problem.toMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L295-L296","name":"Lean.Meta.Match.withGoalOf","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.withGoalOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L293-L293","name":"Lean.Meta.Match.instInhabitedProblem","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.instInhabitedProblem","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L288-L293","name":"Lean.Meta.Match.Problem","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Problem","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L285-L286","name":"Lean.Meta.Match.examplesToMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.examplesToMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L275-L281","name":"Lean.Meta.Match.Example.toMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Example.toMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L269-L273","name":"Lean.Meta.Match.Example.varsToUnderscore","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Example.varsToUnderscore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L260-L267","name":"Lean.Meta.Match.Example.applyFVarSubst","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Example.applyFVarSubst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L254-L258","name":"Lean.Meta.Match.Example.replaceFVarId","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Example.replaceFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L245-L250","name":"Lean.Meta.Match.Example","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Example","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L232-L241","name":"Lean.Meta.Match.Alt.checkAndReplaceFVarId","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt.checkAndReplaceFVarId","doc":"Similar to `checkAndReplaceFVarId`, but ensures type of `v` is definitionally equal to type of `fvarId`.\n  This extra check is necessary when performing dependent elimination and inaccessible terms have been used.\n  For example, consider the following code fragment:\n\n```\ninductive Vec (α : Type u) : Nat → Type u where\n  | nil : Vec α 0\n  | cons {n} (head : α) (tail : Vec α n) : Vec α (n+1)\n\ninductive VecPred {α : Type u} (P : α → Prop) : {n : Nat} → Vec α n → Prop where\n  | nil   : VecPred P Vec.nil\n  | cons  {n : Nat} {head : α} {tail : Vec α n} : P head → VecPred P tail → VecPred P (Vec.cons head tail)\n\ntheorem ex {α : Type u} (P : α → Prop) : {n : Nat} → (v : Vec α (n+1)) → VecPred P v → Exists P\n  | _, Vec.cons head _, VecPred.cons h (w : VecPred P Vec.nil) => ⟨head, h⟩\n```\nRecall that `_` in a pattern can be elaborated into pattern variable or an inaccessible term.\nThe elaborator uses an inaccessible term when typing constraints restrict its value.\nThus, in the example above, the `_` at `Vec.cons head _` becomes the inaccessible pattern `.(Vec.nil)`\nbecause the type ascription `(w : VecPred P Vec.nil)` propagates typing constraints that restrict its value to be `Vec.nil`.\nAfter elaboration the alternative becomes:\n```\n  | .(0), @Vec.cons .(α) .(0) head .(Vec.nil), @VecPred.cons .(α) .(P) .(0) .(head) .(Vec.nil) h w => ⟨head, h⟩\n```\nwhere\n```\n(head : α), (h: P head), (w : VecPred P Vec.nil)\n```\nThen, when we process this alternative in this module, the following check will detect that\n`w` has type `VecPred P Vec.nil`, when it is supposed to have type `VecPred P tail`.\nNote that if we had written\n```\ntheorem ex {α : Type u} (P : α → Prop) : {n : Nat} → (v : Vec α (n+1)) → VecPred P v → Exists P\n  | _, Vec.cons head Vec.nil, VecPred.cons h (w : VecPred P Vec.nil) => ⟨head, h⟩\n```\nwe would get the easier to digest error message\n```\nmissing cases:\n_, (Vec.cons _ _ (Vec.cons _ _ _)), _\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L187-L188","name":"Lean.Meta.Match.Alt.isLocalDecl","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt.isLocalDecl","doc":"Return `true` if `fvarId` is one of the alternative pattern variables "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L177-L184","name":"Lean.Meta.Match.Alt.replaceFVarId","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt.replaceFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L170-L175","name":"Lean.Meta.Match.Alt.applyFVarSubst","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt.applyFVarSubst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L162-L168","name":"Lean.Meta.Match.Alt.toMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt.toMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L158-L158","name":"Lean.Meta.Match.instInhabitedAlt","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.instInhabitedAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L131-L158","name":"Lean.Meta.Match.Alt","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Alt","doc":"`Match` alternative "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L124-L128","name":"Lean.Meta.Match.instantiateAltLHSMVars","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.instantiateAltLHSMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L120-L122","name":"Lean.Meta.Match.AltLHS.collectFVars","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.AltLHS.collectFVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L115-L118","name":"Lean.Meta.Match.AltLHS","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.AltLHS","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L107-L113","name":"Lean.Meta.Match.instantiatePatternMVars","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.instantiatePatternMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L94-L103","name":"Lean.Meta.Match.Pattern.collectFVars","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.collectFVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L85-L91","name":"Lean.Meta.Match.Pattern.hasExprMVar","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.hasExprMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L81-L83","name":"Lean.Meta.Match.Pattern.replaceFVarId","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.replaceFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L69-L79","name":"Lean.Meta.Match.Pattern.applyFVarSubst","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.applyFVarSubst","doc":"Apply the free variable substitution `s` to the given pattern "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L46-L66","name":"Lean.Meta.Match.Pattern.toExpr.visit","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.toExpr.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L43-L66","name":"Lean.Meta.Match.Pattern.toExpr","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.toExpr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L34-L41","name":"Lean.Meta.Match.Pattern.toMessageData","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern.toMessageData","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L30-L30","name":"Lean.Meta.Match.instInhabitedPattern","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.instInhabitedPattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L23-L30","name":"Lean.Meta.Match.Pattern","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L16-L21","name":"Lean.Meta.Match.isNamedPattern?","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.isNamedPattern?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Meta/Match/Basic.lean#L13-L14","name":"Lean.Meta.Match.mkNamedPattern","docLink":"./Lean/Meta/Match/Basic.html#Lean.Meta.Match.mkNamedPattern","doc":""}]}