{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L661-L662","name":"Lean.Parser.Tactic.quotSeq","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L659-L660","name":"Lean.Parser.Tactic.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L654-L655","name":"Lean.Parser.Term.dotIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L651-L652","name":"Lean.Parser.Term.dynamicQuot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L648-L649","name":"Lean.Parser.Term.stateRefT","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L645-L645","name":"Lean.Parser.Term.macroLastArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L644-L644","name":"Lean.Parser.Term.macroDollarArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L643-L643","name":"Lean.Parser.Term.macroArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L639-L640","name":"Lean.Parser.Term.assert","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L635-L637","name":"Lean.Parser.Term.dbgTrace","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L629-L630","name":"Lean.Parser.Term.unreachable","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L626-L627","name":"Lean.Parser.Term.panic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L616-L616","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L615-L615","name":"Lean.Parser.Term.bracketedBinderF","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L612-L613","name":"Lean.Parser.Term.subst","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L601-L602","name":"Lean.Parser.Term.pipeCompletion","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L599-L600","name":"Lean.Parser.Term.pipeProj","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L590-L593","name":"Lean.Parser.Term.namedPattern","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L585-L588","name":"Lean.Parser.Term.explicitUniv","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L580-L582","name":"Lean.Parser.Term.isIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L577-L578","name":"Lean.Parser.Term.arrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L575-L576","name":"Lean.Parser.Term.completion","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L573-L574","name":"Lean.Parser.Term.proj","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L559-L559","name":"Lean.Parser.Term.app","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L552-L555","name":"Lean.Parser.Term.argument","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L550-L551","name":"Lean.Parser.Term.ellipsis","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L548-L549","name":"Lean.Parser.Term.namedArgument","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L545-L546","name":"Lean.Parser.Term.noErrorIfUnused","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L538-L539","name":"Lean.Parser.Term.defaultOrOfNonempty","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L535-L536","name":"Lean.Parser.Term.waitIfContainsMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L533-L534","name":"Lean.Parser.Term.waitIfTypeContainsMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L531-L532","name":"Lean.Parser.Term.waitIfTypeMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L529-L530","name":"Lean.Parser.Term.letMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L526-L527","name":"Lean.Parser.Term.clear","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L519-L520","name":"Lean.Parser.Term.noImplicitLambda","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L517-L518","name":"Lean.Parser.Term.ensureExpectedType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L515-L516","name":"Lean.Parser.Term.ensureTypeOf","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L513-L514","name":"Lean.Parser.Term.typeOf","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L511-L512","name":"Lean.Parser.Term.withDeclName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L503-L503","name":"Lean.Parser.Term.declName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L499-L500","name":"Lean.Parser.Term.forInMacro'","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L497-L498","name":"Lean.Parser.Term.forInMacro","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L494-L495","name":"Lean.Parser.Term.unop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L492-L493","name":"Lean.Parser.Term.binop_lazy","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L490-L491","name":"Lean.Parser.Term.binop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L488-L489","name":"Lean.Parser.Term.binrel_no_prop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"Similar to `binrel`, but coerce `Prop` arguments into `Bool`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L485-L486","name":"Lean.Parser.Term.binrel","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L482-L483","name":"Lean.Parser.Term.noindex","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L479-L480","name":"Lean.Parser.Term.matchAltsWhereDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L475-L476","name":"Lean.Parser.Term.whereDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L470-L472","name":"Lean.Parser.Term.letrec","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L467-L468","name":"Lean.Parser.Term.letRecDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L465-L466","name":"Lean.Parser.Term.letRecDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L463-L464","name":"Lean.Parser.Term.attributes","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L461-L461","name":"Lean.Parser.Term.attrInstance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L460-L460","name":"Lean.Parser.Term.attrKind","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L459-L459","name":"Lean.Parser.Term.local","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L458-L458","name":"Lean.Parser.Term.scoped","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L455-L456","name":"Lean.Parser.Term.have","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L453-L454","name":"Lean.Parser.Term.haveDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L451-L452","name":"Lean.Parser.Term.haveEqnsDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L449-L450","name":"Lean.Parser.Term.haveIdDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L448-L448","name":"Lean.Parser.Term.haveIdLhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L444-L445","name":"Lean.Parser.Term.let_tmp","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L438-L439","name":"Lean.Parser.Term.let_delayed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L433-L434","name":"Lean.Parser.Term.let_fun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L426-L427","name":"Lean.Parser.Term.let","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L402-L404","name":"Lean.Parser.Term.letDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L398-L399","name":"Lean.Parser.Term.letEqnsDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L380-L381","name":"Lean.Parser.Term.letPatDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L378-L379","name":"Lean.Parser.Term.letIdDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L374-L377","name":"Lean.Parser.Term.letIdLhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L370-L372","name":"Lean.Parser.Term.letIdBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L367-L368","name":"Lean.Parser.Term.doubleQuotedName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L360-L360","name":"Lean.Parser.Term.quotedName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L357-L358","name":"Lean.Parser.Term.borrowed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L354-L355","name":"Lean.Parser.Term.trailing_parser","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L352-L353","name":"Lean.Parser.Term.leading_parser","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L349-L351","name":"Lean.Parser.Term.withAnonymousAntiquot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L348-L348","name":"Lean.Parser.Term.optExprPrecedence","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L345-L346","name":"Lean.Parser.Term.fun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L343-L344","name":"Lean.Parser.Term.basicFun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L338-L340","name":"Lean.Parser.Term.funBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L333-L337","name":"Lean.Parser.Term.funStrictImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L331-L332","name":"Lean.Parser.Term.funImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L329-L329","name":"Lean.Parser.Term.nomatch","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L321-L323","name":"Lean.Parser.Term.match","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L287-L289","name":"Lean.Parser.Term.motive","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L283-L285","name":"Lean.Parser.Term.generalizingParam","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L282-L282","name":"Lean.Parser.Term.falseVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L281-L281","name":"Lean.Parser.Term.trueVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L278-L279","name":"Lean.Parser.Term.matchDiscr","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L275-L276","name":"Lean.Parser.Term.matchAlts","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L272-L273","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L270-L270","name":"Lean.Parser.Term.matchAltExpr","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L261-L266","name":"Lean.Parser.Term.matchAlt","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L256-L259","name":"Lean.Parser.Term.forall","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L252-L253","name":"Lean.Parser.Term.depArrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L232-L235","name":"Lean.Parser.Term.bracketedBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L230-L231","name":"Lean.Parser.Term.instBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by typeclass inference of the specified class.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L223-L225","name":"Lean.Parser.Term.strictImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders,\na strict-implicit binder is inserted automatically only when at least one subsequent\nexplicit parameter is specified.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L217-L217","name":"Lean.Parser.Term.strictImplicitRightBracket","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L216-L216","name":"Lean.Parser.Term.strictImplicitLeftBracket","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L214-L215","name":"Lean.Parser.Term.implicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by unification whenever all explicit parameters before it are specified.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L208-L209","name":"Lean.Parser.Term.explicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L206-L207","name":"Lean.Parser.Term.binderDefault","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L204-L205","name":"Lean.Parser.Term.binderTactic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L202-L203","name":"Lean.Parser.Term.binderType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L201-L201","name":"Lean.Parser.Term.binderIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L199-L200","name":"Lean.Parser.Term.inaccessible","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L193-L194","name":"Lean.Parser.Term.explicit","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L188-L188","name":"Lean.Parser.Term.optType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L187-L187","name":"Lean.Parser.Term.typeSpec","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L182-L186","name":"Lean.Parser.Term.structInst","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L171-L172","name":"Lean.Parser.Term.optEllipsis","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L168-L170","name":"Lean.Parser.Term.structInstFieldAbbrev","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L166-L167","name":"Lean.Parser.Term.structInstField","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L163-L165","name":"Lean.Parser.Term.structInstLVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L161-L162","name":"Lean.Parser.Term.structInstArrayRef","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L160-L160","name":"Lean.Parser.Term.show","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L158-L159","name":"Lean.Parser.Term.suffices","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L156-L157","name":"Lean.Parser.Term.sufficesDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L155-L155","name":"Lean.Parser.Term.showRhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L153-L154","name":"Lean.Parser.Term.fromTerm","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L151-L152","name":"Lean.Parser.Term.optIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L149-L150","name":"Lean.Parser.Term.anonymousCtor","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L140-L141","name":"Lean.Parser.Term.paren","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for\n- Grouping expressions, e.g., `a * (b + c)`.\n- Creating tuples, e.g., `(a, b, c)` is notation for `Prod.mk a (Prod.mk b c)`.\n- Performing type ascription, e.g., `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\n- Creating `Unit.unit`, `()` is just a shorthand for `Unit.unit`.\n- Creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L126-L127","name":"Lean.Parser.Term.parenSpecial","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.parenSpecial","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L124-L125","name":"Lean.Parser.Term.tupleTail","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tupleTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L122-L123","name":"Lean.Parser.Term.typeAscription","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L120-L121","name":"Lean.Parser.Term.cdot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L114-L115","name":"Lean.Parser.Term.sorry","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L111-L112","name":"Lean.Parser.Term.syntheticHole","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L109-L110","name":"Lean.Parser.Term.hole","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L106-L107","name":"Lean.Parser.Term.prop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L103-L104","name":"Lean.Parser.Term.sort","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L100-L101","name":"Lean.Parser.Term.type","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L97-L98","name":"Lean.Parser.Term.char","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L95-L96","name":"Lean.Parser.Term.str","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L93-L94","name":"Lean.Parser.Term.scientific","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L91-L92","name":"Lean.Parser.Term.num","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L89-L90","name":"Lean.Parser.Term.ident","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L85-L86","name":"Lean.Parser.Term.optSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L81-L82","name":"Lean.Parser.Term.byTactic'","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L72-L73","name":"Lean.Parser.Term.byTactic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L65-L65","name":"Lean.Parser.semicolonOrLinebreak","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L64-L64","name":"Lean.Parser.darrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L59-L60","name":"Lean.Parser.Tactic.seq1","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L55-L56","name":"Lean.Parser.Tactic.tacticSeq","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L53-L54","name":"Lean.Parser.Tactic.tacticSeqBracketed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L49-L50","name":"Lean.Parser.Tactic.tacticSeq1Indented","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L42-L43","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L38-L39","name":"Lean.Parser.Tactic.sepByIndentSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L32-L33","name":"Lean.Parser.convParser","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L29-L30","name":"Lean.Parser.tacticParser","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L21-L22","name":"Lean.Parser.Command.docComment","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.commentBody.formatter","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.parenthesizer","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""}]}