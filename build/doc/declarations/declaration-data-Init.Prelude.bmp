{"name":"Init.Prelude","instances":[{"typeNames":[],"name":"instNonempty","className":"Nonempty"},{"typeNames":[],"name":"instNonemptyForAll","className":"Nonempty"},{"typeNames":[],"name":"instNonemptyForAll_1","className":"Nonempty"},{"typeNames":[],"name":"instInhabitedSort","className":"Inhabited"},{"typeNames":[],"name":"instInhabitedForAll","className":"Inhabited"},{"typeNames":[],"name":"instInhabitedForAll_1","className":"Inhabited"},{"typeNames":["Bool"],"name":"instInhabitedBool","className":"Inhabited"},{"typeNames":["NonemptyType"],"name":"instInhabitedNonemptyType","className":"Inhabited"},{"typeNames":["Eq","Bool"],"name":"instDecidableEqBool","className":"Decidable"},{"typeNames":[],"name":"instBEq","className":"BEq"},{"typeNames":["And"],"name":"instDecidableAnd","className":"Decidable"},{"typeNames":["Or"],"name":"instDecidableOr","className":"Decidable"},{"typeNames":["Not"],"name":"instDecidableNot","className":"Decidable"},{"typeNames":["Nat"],"name":"instInhabitedNat","className":"Inhabited"},{"typeNames":["Nat"],"name":"instOfNatNat","className":"OfNat"},{"typeNames":["Eq"],"name":"instTransEq","className":"Trans"},{"typeNames":["Eq"],"name":"instTransEq_1","className":"Trans"},{"typeNames":[],"name":"instHAdd","className":"HAdd"},{"typeNames":[],"name":"instHSub","className":"HSub"},{"typeNames":[],"name":"instHMul","className":"HMul"},{"typeNames":[],"name":"instHDiv","className":"HDiv"},{"typeNames":[],"name":"instHMod","className":"HMod"},{"typeNames":[],"name":"instHPow","className":"HPow"},{"typeNames":[],"name":"instHAppend","className":"HAppend"},{"typeNames":[],"name":"instHOrElse","className":"HOrElse"},{"typeNames":[],"name":"instHAndThen","className":"HAndThen"},{"typeNames":[],"name":"instHAnd","className":"HAnd"},{"typeNames":[],"name":"instHXor","className":"HXor"},{"typeNames":[],"name":"instHOr","className":"HOr"},{"typeNames":[],"name":"instHShiftLeft","className":"HShiftLeft"},{"typeNames":[],"name":"instHShiftRight","className":"HShiftRight"},{"typeNames":["Nat"],"name":"instAddNat","className":"Add"},{"typeNames":["Nat"],"name":"instMulNat","className":"Mul"},{"typeNames":["Nat","Nat"],"name":"instPowNat","className":"Pow"},{"typeNames":["Nat"],"name":"instBEqNat","className":"BEq"},{"typeNames":["Eq","Nat"],"name":"instDecidableEqNat","className":"Decidable"},{"typeNames":["Nat"],"name":"instLENat","className":"LE"},{"typeNames":["Nat"],"name":"instLTNat","className":"LT"},{"typeNames":["LE.le","Nat","instLENat"],"name":"Nat.decLe","className":"Decidable"},{"typeNames":["LT.lt","Nat","instLTNat"],"name":"Nat.decLt","className":"Decidable"},{"typeNames":["Nat"],"name":"instSubNat","className":"Sub"},{"typeNames":["Eq","Fin"],"name":"instDecidableEqFin","className":"Decidable"},{"typeNames":["Fin"],"name":"instLTFin","className":"LT"},{"typeNames":["Fin"],"name":"instLEFin","className":"LE"},{"typeNames":["LT.lt","Fin","instLTFin"],"name":"Fin.decLt","className":"Decidable"},{"typeNames":["LE.le","Fin","instLEFin"],"name":"Fin.decLe","className":"Decidable"},{"typeNames":["Eq","UInt8"],"name":"instDecidableEqUInt8","className":"Decidable"},{"typeNames":["UInt8"],"name":"instInhabitedUInt8","className":"Inhabited"},{"typeNames":["Eq","UInt16"],"name":"instDecidableEqUInt16","className":"Decidable"},{"typeNames":["UInt16"],"name":"instInhabitedUInt16","className":"Inhabited"},{"typeNames":["Eq","UInt32"],"name":"instDecidableEqUInt32","className":"Decidable"},{"typeNames":["UInt32"],"name":"instInhabitedUInt32","className":"Inhabited"},{"typeNames":["UInt32"],"name":"instLTUInt32","className":"LT"},{"typeNames":["UInt32"],"name":"instLEUInt32","className":"LE"},{"typeNames":["LT.lt","UInt32","instLTUInt32"],"name":"instDecidableLtUInt32InstLTUInt32","className":"Decidable"},{"typeNames":["LE.le","UInt32","instLEUInt32"],"name":"instDecidableLeUInt32InstLEUInt32","className":"Decidable"},{"typeNames":["UInt32"],"name":"instMaxUInt32","className":"Max"},{"typeNames":["UInt32"],"name":"instMinUInt32","className":"Min"},{"typeNames":["Eq","UInt64"],"name":"instDecidableEqUInt64","className":"Decidable"},{"typeNames":["UInt64"],"name":"instInhabitedUInt64","className":"Inhabited"},{"typeNames":["Eq","USize"],"name":"instDecidableEqUSize","className":"Decidable"},{"typeNames":["USize"],"name":"instInhabitedUSize","className":"Inhabited"},{"typeNames":["Eq","Char"],"name":"instDecidableEqChar","className":"Decidable"},{"typeNames":["Option"],"name":"instInhabitedOption","className":"Inhabited"},{"typeNames":["List"],"name":"instInhabitedList","className":"Inhabited"},{"typeNames":["Eq","List"],"name":"instDecidableEqList","className":"Decidable"},{"typeNames":["Eq","String"],"name":"instDecidableEqString","className":"Decidable"},{"typeNames":["String.Pos"],"name":"instInhabitedPos","className":"Inhabited"},{"typeNames":["Eq","String.Pos"],"name":"instDecidableEqPos","className":"Decidable"},{"typeNames":["Substring"],"name":"instInhabitedSubstring","className":"Inhabited"},{"typeNames":["String.Pos","String.Pos","String.Pos"],"name":"instHAddPos","className":"HAdd"},{"typeNames":["String.Pos","String.Pos","String.Pos"],"name":"instHSubPos","className":"HSub"},{"typeNames":["String.Pos","Char","String.Pos"],"name":"instHAddPosChar","className":"HAdd"},{"typeNames":["String.Pos","String","String.Pos"],"name":"instHAddPosString","className":"HAdd"},{"typeNames":["String.Pos"],"name":"instLEPos","className":"LE"},{"typeNames":["String.Pos"],"name":"instLTPos","className":"LT"},{"typeNames":["LE.le","String.Pos","instLEPos"],"name":"instDecidableLePosInstLEPos","className":"Decidable"},{"typeNames":["LT.lt","String.Pos","instLTPos"],"name":"instDecidableLtPosInstLTPos","className":"Decidable"},{"typeNames":["Array","Nat","Array","Nat","LT.lt","instLTNat","Array.size"],"name":"instGetElemArrayNatLtInstLTNatSize","className":"GetElem"},{"typeNames":[],"name":"instInhabitedForAll_2","className":"Inhabited"},{"typeNames":[],"name":"instInhabited","className":"Inhabited"},{"typeNames":[],"name":"instForAllNonemptyNonempty","className":"Nonempty"},{"typeNames":[],"name":"instMonadLiftT","className":"MonadLiftT"},{"typeNames":[],"name":"instMonadLiftT_1","className":"MonadLiftT"},{"typeNames":[],"name":"instMonadFunctorT","className":"MonadFunctorT"},{"typeNames":[],"name":"monadFunctorRefl","className":"MonadFunctorT"},{"typeNames":["Except"],"name":"instInhabitedExcept","className":"Inhabited"},{"typeNames":[],"name":"instMonadExcept","className":"MonadExcept"},{"typeNames":[],"name":"MonadExcept.instOrElse","className":"OrElse"},{"typeNames":["ReaderT"],"name":"instInhabitedReaderT","className":"Inhabited"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadLiftReaderT","className":"MonadLift"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadExceptOfReaderT","className":"MonadExceptOf"},{"typeNames":["ReaderT"],"name":"ReaderT.instFunctorReaderT","className":"Functor"},{"typeNames":["ReaderT"],"name":"ReaderT.instApplicativeReaderT","className":"Applicative"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadReaderT","className":"Monad"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadFunctorReaderT","className":"MonadFunctor"},{"typeNames":[],"name":"instMonadReader","className":"MonadReader"},{"typeNames":[],"name":"instMonadReaderOf","className":"MonadReaderOf"},{"typeNames":["ReaderT"],"name":"instMonadReaderOfReaderT","className":"MonadReaderOf"},{"typeNames":[],"name":"instMonadWithReader","className":"MonadWithReader"},{"typeNames":[],"name":"instMonadWithReaderOf","className":"MonadWithReaderOf"},{"typeNames":["ReaderT"],"name":"instMonadWithReaderOfReaderT","className":"MonadWithReaderOf"},{"typeNames":[],"name":"instMonadState","className":"MonadState"},{"typeNames":[],"name":"instMonadStateOf","className":"MonadStateOf"},{"typeNames":["EStateM.Result"],"name":"EStateM.instInhabitedResult","className":"Inhabited"},{"typeNames":["EStateM"],"name":"EStateM.instInhabitedEStateM","className":"Inhabited"},{"typeNames":["EStateM"],"name":"EStateM.instMonadEStateM","className":"Monad"},{"typeNames":["EStateM"],"name":"EStateM.instOrElseEStateM","className":"OrElse"},{"typeNames":["EStateM"],"name":"EStateM.instMonadStateOfEStateM","className":"MonadStateOf"},{"typeNames":["EStateM"],"name":"EStateM.instMonadExceptOfEStateM","className":"MonadExceptOf"},{"typeNames":["PUnit"],"name":"EStateM.nonBacktrackable","className":"EStateM.Backtrackable"},{"typeNames":["Subtype"],"name":"instHashableSubtype","className":"Hashable"},{"typeNames":["String"],"name":"instHashableString","className":"Hashable"},{"typeNames":["Lean.Name"],"name":"Lean.instInhabitedName","className":"Inhabited"},{"typeNames":["Lean.Name"],"name":"Lean.instHashableName","className":"Hashable"},{"typeNames":["Lean.Name"],"name":"Lean.Name.instBEqName","className":"BEq"},{"typeNames":["Lean.Name"],"name":"Lean.Name.instAppendName","className":"Append"},{"typeNames":["Lean.SourceInfo"],"name":"Lean.instInhabitedSourceInfo","className":"Inhabited"},{"typeNames":["Lean.Syntax"],"name":"Lean.instInhabitedSyntax","className":"Inhabited"},{"typeNames":["Lean.TSyntax"],"name":"Lean.instInhabitedTSyntax","className":"Inhabited"},{"typeNames":["Lean.Syntax","Nat","Lean.Syntax","Lean.Syntax","Nat","True"],"name":"Lean.Syntax.instGetElemSyntaxNatTrue","className":"GetElem"},{"typeNames":["Lean.ParserDescr"],"name":"Lean.instInhabitedParserDescr","className":"Inhabited"},{"typeNames":[],"name":"Lean.instMonadRef","className":"Lean.MonadRef"},{"typeNames":[],"name":"Lean.instMonadQuotation","className":"Lean.MonadQuotation"},{"typeNames":["Lean.MacroScopesView"],"name":"Lean.instInhabitedMacroScopesView","className":"Inhabited"},{"typeNames":["_private.Init.Prelude.0.Lean.Macro.MethodsRef"],"name":"Lean.Macro.instNonemptyMethodsRef","className":"Nonempty"},{"typeNames":["Lean.Macro.State"],"name":"Lean.Macro.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.MacroM"],"name":"Lean.Macro.instMonadRefMacroM","className":"Lean.MonadRef"},{"typeNames":["Lean.MacroM"],"name":"Lean.Macro.instMonadQuotationMacroM","className":"Lean.MonadQuotation"},{"typeNames":["Lean.Macro.Methods"],"name":"Lean.Macro.instInhabitedMethods","className":"Inhabited"},{"typeNames":["_private.Init.Prelude.0.Lean.Macro.MethodsRef"],"name":"Lean.Macro.instInhabitedMethodsRef","className":"Inhabited"},{"typeNames":["Lean.PrettyPrinter.UnexpandM"],"name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","className":"Lean.MonadQuotation"}],"imports":[],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4444-L4450","name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.instMonadQuotationUnexpandM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4442-L4442","name":"Lean.PrettyPrinter.Unexpander","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander","doc":"Function that tries to reverse macro expansions as a post-processing step of delaboration.\nWhile less general than an arbitrary delaborator, it can be declared without importing `Lean`.\nUsed by the `[app_unexpander]` attribute.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4434-L4434","name":"Lean.PrettyPrinter.UnexpandM","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.UnexpandM","doc":"The unexpander monad, essentially `Syntax → Option α`. The `Syntax` is the `ref`,\nand it has the possibility of failure without an error message.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4421-L4422","name":"Lean.Macro.trace","docLink":"./Init/Prelude.html#Lean.Macro.trace","doc":"Add a new trace message, with the given trace class and message. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4417-L4418","name":"Lean.Macro.resolveGlobalName","docLink":"./Init/Prelude.html#Lean.Macro.resolveGlobalName","doc":"Resolves the given name to a overload list of global definitions.\nThe `List String` in each alternative is the deduced list of projections\n(which are ambiguous with name components).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4409-L4410","name":"Lean.Macro.resolveNamespace","docLink":"./Init/Prelude.html#Lean.Macro.resolveNamespace","doc":"Resolves the given name to an overload list of namespaces. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4405-L4406","name":"Lean.Macro.getCurrNamespace","docLink":"./Init/Prelude.html#Lean.Macro.getCurrNamespace","doc":"Gets the current namespace given the position in the file. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4401-L4402","name":"Lean.Macro.hasDecl","docLink":"./Init/Prelude.html#Lean.Macro.hasDecl","doc":"Returns `true` if the environment contains a declaration with name `declName` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4397-L4398","name":"Lean.Macro.expandMacro?","docLink":"./Init/Prelude.html#Lean.Macro.expandMacro?","doc":"`expandMacro? stx` returns `some stxNew` if `stx` is a macro,\nand `stxNew` is its expansion.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4391-L4391","name":"Lean.Macro.getMethods","docLink":"./Init/Prelude.html#Lean.Macro.getMethods","doc":"Extract the methods list from the `MacroM` state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4387-L4388","name":"Lean.Macro.getMethodsImp","docLink":"./Init/Prelude.html#Lean.Macro.getMethodsImp","doc":"Implementation of `getMethods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4383-L4384","name":"Lean.Macro.instInhabitedMethodsRef","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4381-L4381","name":"Lean.Macro.mkMethods","docLink":"./Init/Prelude.html#Lean.Macro.mkMethods","doc":"Make an opaque reference to a `Methods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4376-L4377","name":"Lean.Macro.mkMethodsImp","docLink":"./Init/Prelude.html#Lean.Macro.mkMethodsImp","doc":"Implementation of `mkMethods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4373-L4373","name":"Lean.Macro.instInhabitedMethods","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedMethods","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4359-L4373","name":"Lean.Macro.Methods","docLink":"./Init/Prelude.html#Lean.Macro.Methods","doc":"The opaque methods that are available to `MacroM`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4353-L4356","name":"Lean.Macro.instMonadQuotationMacroM","docLink":"./Init/Prelude.html#Lean.Macro.instMonadQuotationMacroM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4347-L4351","name":"Lean.Macro.withIncRecDepth","docLink":"./Init/Prelude.html#Lean.Macro.withIncRecDepth","doc":"Run `x` with an incremented recursion depth counter. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4342-L4344","name":"Lean.Macro.withFreshMacroScope","docLink":"./Init/Prelude.html#Lean.Macro.withFreshMacroScope","doc":"Increments the macro scope counter so that inside the body of `x` the macro\nscope is fresh.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4335-L4336","name":"Lean.Macro.throwErrorAt","docLink":"./Init/Prelude.html#Lean.Macro.throwErrorAt","doc":"Throw a error with the given message and location information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4330-L4332","name":"Lean.Macro.throwError","docLink":"./Init/Prelude.html#Lean.Macro.throwError","doc":"Throw a error with the given message,\nusing the `ref` for the location information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4323-L4324","name":"Lean.Macro.throwUnsupported","docLink":"./Init/Prelude.html#Lean.Macro.throwUnsupported","doc":"Throw an `unsupportedSyntax` exception. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4318-L4320","name":"Lean.Macro.addMacroScope","docLink":"./Init/Prelude.html#Lean.Macro.addMacroScope","doc":"Add a new macro scope to the name `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4313-L4315","name":"Lean.Macro.instMonadRefMacroM","docLink":"./Init/Prelude.html#Lean.Macro.instMonadRefMacroM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4309-L4309","name":"Lean.Macro","docLink":"./Init/Prelude.html#Lean.Macro","doc":"A `macro` has type `Macro`, which is a `Syntax → MacroM Syntax`: it\nreceives an input syntax and is supposed to \"expand\" it into another piece of\nsyntax.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4302-L4302","name":"Lean.MacroM","docLink":"./Init/Prelude.html#Lean.MacroM","doc":"The `MacroM` monad is the main monad for macro expansion. It has the\ninformation needed to handle hygienic name generation, and is the monad that\n`macro` definitions live in.\n\nNotably, this is a (relatively) pure monad: there is no `IO` and no access to\nthe `Environment`. That means that things like declaration lookup are\nimpossible here, as well as `IO.Ref` or other side-effecting operations.\nFor more capabilities, macros can instead be written as `elab` using `adaptExpander`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4288-L4288","name":"Lean.Macro.instInhabitedState","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4282-L4288","name":"Lean.Macro.State","docLink":"./Init/Prelude.html#Lean.Macro.State","doc":"The mutable state for the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4273-L4279","name":"Lean.Macro.Exception","docLink":"./Init/Prelude.html#Lean.Macro.Exception","doc":"An exception in the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4257-L4270","name":"Lean.Macro.Context","docLink":"./Init/Prelude.html#Lean.Macro.Context","doc":"The read-only context for the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4254-L4254","name":"Lean.Macro.instNonemptyMethodsRef","docLink":"./Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4238-L4243","name":"Lean.Syntax.matchesLit","docLink":"./Init/Prelude.html#Lean.Syntax.matchesLit","doc":"Is this syntax a node kind `k` wrapping an `atom _ val`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4234-L4235","name":"Lean.Syntax.matchesIdent","docLink":"./Init/Prelude.html#Lean.Syntax.matchesIdent","doc":"Function used for determining whether a syntax pattern `` `(id) `` is matched.\nThere are various conceivable notions of when two syntactic identifiers should be regarded as identical,\nbut semantic definitions like whether they refer to the same global name cannot be implemented without\ncontext information (i.e. `MonadResolveName`). Thus in patterns we default to the structural solution\nof comparing the identifiers' `Name` values, though we at least do so modulo macro scopes so that\nidentifiers that \"look\" the same match. This is particularly useful when dealing with identifiers that\ndo not actually refer to Lean bindings, e.g. in the `stx` pattern `` `(many($p)) ``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4223-L4224","name":"Lean.Syntax.matchesNull","docLink":"./Init/Prelude.html#Lean.Syntax.matchesNull","doc":"Is this syntax a null `node`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4217-L4218","name":"Lean.maxRecDepthErrorMessage","docLink":"./Init/Prelude.html#Lean.maxRecDepthErrorMessage","doc":"The message to display on stack overflow. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4214-L4214","name":"Lean.defaultMaxRecDepth","docLink":"./Init/Prelude.html#Lean.defaultMaxRecDepth","doc":"The default maximum recursion depth. This is adjustable using the `maxRecDepth` option. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4208-L4211","name":"Lean.MonadQuotation.addMacroScope","docLink":"./Init/Prelude.html#Lean.MonadQuotation.addMacroScope","doc":"Add a new macro scope onto the name `n`, using the monad state to supply the\nmain module and current macro scope.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4189-L4202","name":"Lean.addMacroScope","docLink":"./Init/Prelude.html#Lean.addMacroScope","doc":"Add a new macro scope onto the name `n`, in the given `mainModule`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4183-L4186","name":"Lean.extractMacroScopes","docLink":"./Init/Prelude.html#Lean.extractMacroScopes","doc":"Revert all `addMacroScope` calls. `v = extractMacroScopes n → n = v.review`.\nThis operation is useful for analyzing/transforming the original identifiers, then adding back\nthe scopes (via `MacroScopesView.review`). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4145-L4150","name":"Lean.MacroScopesView.review","docLink":"./Init/Prelude.html#Lean.MacroScopesView.review","doc":"Encode a hygienic name from the parsed pieces. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4141-L4142","name":"Lean.instInhabitedMacroScopesView","docLink":"./Init/Prelude.html#Lean.instInhabitedMacroScopesView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4130-L4139","name":"Lean.MacroScopesView","docLink":"./Init/Prelude.html#Lean.MacroScopesView","doc":"A `MacroScopesView` represents a parsed hygienic name. `extractMacroScopes`\nwill decode it from a `Name`, and `.review` will re-encode it. The grammar of a\nhygienic name is:\n```\n<name>._@.(<module_name>.<scopes>)*.<mainModule>._hyg.<scopes>\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4117-L4120","name":"Lean.Name.simpMacroScopes","docLink":"./Init/Prelude.html#Lean.Name.simpMacroScopes","doc":"Helper function we use to create binder names that do not need to be unique. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4106-L4109","name":"Lean.Name.eraseMacroScopes","docLink":"./Init/Prelude.html#Lean.Name.eraseMacroScopes","doc":"Remove the macro scopes from the name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4092-L4095","name":"Lean.Name.hasMacroScopes","docLink":"./Init/Prelude.html#Lean.Name.hasMacroScopes","doc":"Does this name have hygienic macro scopes? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4065-L4068","name":"Lean.instMonadQuotation","docLink":"./Init/Prelude.html#Lean.instMonadQuotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4062-L4063","name":"Lean.MonadRef.mkInfoFromRefPos","docLink":"./Init/Prelude.html#Lean.MonadRef.mkInfoFromRefPos","doc":"Construct a synthetic `SourceInfo` from the `ref` in the monad state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4037-L4056","name":"Lean.MonadQuotation","docLink":"./Init/Prelude.html#Lean.MonadQuotation","doc":"A monad that supports syntax quotations. Syntax quotations (in term\nposition) are monadic values that when executed retrieve the current \"macro\nscope\" from the monad and apply it to every identifier they introduce\n(independent of whether this identifier turns out to be a reference to an\nexisting declaration, or an actually fresh binding during further\nelaboration). We also apply the position of the result of `getRef` to each\nintroduced symbol, which results in better error positions than not applying\nany position. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4024-L4027","name":"Lean.withRef","docLink":"./Init/Prelude.html#Lean.withRef","doc":"Run `x : m α` with a modified value for the `ref`. This is not exactly\nthe same as `MonadRef.withRef`, because it uses `replaceRef` to avoid putting\nsyntax with bad spans in the state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4013-L4016","name":"Lean.replaceRef","docLink":"./Init/Prelude.html#Lean.replaceRef","doc":"Replaces `oldRef` with `ref`, unless `ref` has no position info.\nThis biases us to having a valid span to report an error on.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L4005-L4007","name":"Lean.instMonadRef","docLink":"./Init/Prelude.html#Lean.instMonadRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3997-L4001","name":"Lean.MonadRef","docLink":"./Init/Prelude.html#Lean.MonadRef","doc":"A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.\nThis is used to keep track of the location where we are working; if an exception\nis thrown, the `ref` gives the location where the error will be reported,\nassuming no more specific location is provided.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3989-L3989","name":"Lean.firstFrontendMacroScope","docLink":"./Init/Prelude.html#Lean.firstFrontendMacroScope","doc":"First macro scope available for our frontend "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3987-L3987","name":"Lean.reservedMacroScope","docLink":"./Init/Prelude.html#Lean.reservedMacroScope","doc":"Macro scope used internally. It is not available for our frontend. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3985-L3985","name":"Lean.MacroScope","docLink":"./Init/Prelude.html#Lean.MacroScope","doc":"A macro scope identifier is just a `Nat` that gets bumped every time we\nenter a new macro scope. Within a macro scope, all occurrences of identifier `x`\nparse to the same thing, but `x` parsed from different macro scopes will\nproduce different identifiers.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3971-L3971","name":"Lean.TrailingParserDescr","docLink":"./Init/Prelude.html#Lean.TrailingParserDescr","doc":"Although `TrailingParserDescr` is an abbreviation for `ParserDescr`, Lean will\nlook at the declared type in order to determine whether to add the parser to\nthe leading or trailing parser table. The determination is done automatically\nby the `syntax` command.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3962-L3963","name":"Lean.instInhabitedParserDescr","docLink":"./Init/Prelude.html#Lean.instInhabitedParserDescr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3918-L3960","name":"Lean.ParserDescr","docLink":"./Init/Prelude.html#Lean.ParserDescr","doc":"A `ParserDescr` is a grammar for parsers. This is used by the `syntax` command\nto produce parsers without having to `import Lean`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3909-L3910","name":"Lean.mkAtomFrom","docLink":"./Init/Prelude.html#Lean.mkAtomFrom","doc":"Constructs a synthetic `atom` with source info coming from `src`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3905-L3906","name":"Lean.mkAtom","docLink":"./Init/Prelude.html#Lean.mkAtom","doc":"Constructs a synthetic `atom` with no source info. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3892-L3902","name":"Lean.SourceInfo.fromRef","docLink":"./Init/Prelude.html#Lean.SourceInfo.fromRef","doc":"Constructs a synthetic `SourceInfo` using a `ref : Syntax` for the span. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3889-L3889","name":"Lean.TSyntaxArray.mk","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.mk","doc":"Converts an `Array Syntax` to a `TSyntaxArray`, without reallocation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3885-L3885","name":"Lean.TSyntaxArray.mkImpl","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.mkImpl","doc":"Implementation of `TSyntaxArray.mk`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3882-L3882","name":"Lean.TSyntaxArray.raw","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.raw","doc":"Converts a `TSyntaxArray` to an `Array Syntax`, without reallocation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3878-L3878","name":"Lean.TSyntaxArray.rawImpl","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.rawImpl","doc":"Implementation of `TSyntaxArray.raw`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3875-L3875","name":"Lean.TSyntaxArray","docLink":"./Init/Prelude.html#Lean.TSyntaxArray","doc":"An array of syntaxes of kind `ks`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3867-L3870","name":"Lean.Syntax.TSepArray","docLink":"./Init/Prelude.html#Lean.Syntax.TSepArray","doc":"A typed version of `SepArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3861-L3864","name":"Lean.Syntax.SepArray","docLink":"./Init/Prelude.html#Lean.Syntax.SepArray","doc":"An array of syntax elements interspersed with separators. Can be coerced\nto/from `Array Syntax` to automatically remove/insert the separators.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3848-L3853","name":"Lean.Syntax.getTailPos?.loop","docLink":"./Init/Prelude.html#Lean.Syntax.getTailPos?.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3836-L3855","name":"Lean.Syntax.getTailPos?","docLink":"./Init/Prelude.html#Lean.Syntax.getTailPos?","doc":"Get the ending position of the syntax, if possible.\nIf `canonicalOnly` is true, non-canonical `synthetic` nodes are treated as not carrying\nposition information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3827-L3828","name":"Lean.Syntax.getPos?","docLink":"./Init/Prelude.html#Lean.Syntax.getPos?","doc":"Get the starting position of the syntax, if possible.\nIf `canonicalOnly` is true, non-canonical `synthetic` nodes are treated as not carrying\nposition information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3817-L3820","name":"Lean.Syntax.getHeadInfo","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo","doc":"Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3806-L3811","name":"Lean.Syntax.getHeadInfo?.loop","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo?.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3802-L3814","name":"Lean.Syntax.getHeadInfo?","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo?","doc":"Retrieve the left-most node or leaf's info in the Syntax tree. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3796-L3799","name":"Lean.Syntax.setArg","docLink":"./Init/Prelude.html#Lean.Syntax.setArg","doc":"Updates the `i`'th argument of the syntax.\nDoes nothing for non-`node` nodes, or if `i` is out of bounds of the node list.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3787-L3790","name":"Lean.Syntax.setArgs","docLink":"./Init/Prelude.html#Lean.Syntax.setArgs","doc":"Updates the argument list without changing the node kind.\nDoes nothing for non-`node` nodes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3779-L3781","name":"Lean.Syntax.getId","docLink":"./Init/Prelude.html#Lean.Syntax.getId","doc":"If this is a `ident`, return the parsed value, else `.anonymous`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3774-L3776","name":"Lean.Syntax.isIdent","docLink":"./Init/Prelude.html#Lean.Syntax.isIdent","doc":"`stx.isIdent` is `true` iff `stx` is an identifier. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3770-L3771","name":"Lean.Syntax.isNodeOf","docLink":"./Init/Prelude.html#Lean.Syntax.isNodeOf","doc":"Is this syntax a `node` with kind `k`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3765-L3767","name":"Lean.Syntax.isMissing","docLink":"./Init/Prelude.html#Lean.Syntax.isMissing","doc":"Is this syntax `.missing`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3757-L3762","name":"Lean.Syntax.getOptional?","docLink":"./Init/Prelude.html#Lean.Syntax.getOptional?","doc":"Assuming `stx` was parsed by `optional`, returns the enclosed syntax\nif it parsed something and `none` otherwise.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3748-L3751","name":"Lean.Syntax.getNumArgs","docLink":"./Init/Prelude.html#Lean.Syntax.getNumArgs","doc":"Gets the number of arguments of the syntax node, or `0` if it's not a `node`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3742-L3745","name":"Lean.Syntax.getArgs","docLink":"./Init/Prelude.html#Lean.Syntax.getArgs","doc":"Gets the list of arguments of the syntax node, or `#[]` if it's not a `node`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3738-L3739","name":"Lean.Syntax.instGetElemSyntaxNatTrue","docLink":"./Init/Prelude.html#Lean.Syntax.instGetElemSyntaxNatTrue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3733-L3736","name":"Lean.Syntax.getArg","docLink":"./Init/Prelude.html#Lean.Syntax.getArg","doc":"Gets the `i`'th argument of the syntax node. This can also be written `stx[i]`.\nReturns `missing` if `i` is out of range.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3726-L3727","name":"Lean.Syntax.isOfKind","docLink":"./Init/Prelude.html#Lean.Syntax.isOfKind","doc":"Is this a syntax with node kind `k`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3720-L3723","name":"Lean.Syntax.setKind","docLink":"./Init/Prelude.html#Lean.Syntax.setKind","doc":"Changes the kind at the root of a `Syntax` node to `k`.\nDoes nothing for non-`node` nodes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3706-L3714","name":"Lean.Syntax.getKind","docLink":"./Init/Prelude.html#Lean.Syntax.getKind","doc":"Gets the kind of a `Syntax` node. For non-`node` syntax, we use \"pseudo kinds\":\n`identKind` for `ident`, `missing` for `missing`, and the atom's string literal\nfor atoms.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3697-L3697","name":"Lean.interpolatedStrKind","docLink":"./Init/Prelude.html#Lean.interpolatedStrKind","doc":"`interpolatedStrKind` is the node kind of an interpolated string literal\nlike `\"value = {x}\"` in `s!\"value = {x}\"`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3692-L3692","name":"Lean.interpolatedStrLitKind","docLink":"./Init/Prelude.html#Lean.interpolatedStrLitKind","doc":"`interpolatedStrLitKind` is the node kind of interpolated string literal\nfragments like `\"value = {` and `}\"` in `s!\"value = {x}\"`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3686-L3686","name":"Lean.fieldIdxKind","docLink":"./Init/Prelude.html#Lean.fieldIdxKind","doc":"`fieldIdx` is the node kind of projection indices like the `2` in `x.2`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3683-L3683","name":"Lean.nameLitKind","docLink":"./Init/Prelude.html#Lean.nameLitKind","doc":"`name` is the node kind of name literals like `` `foo ``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3680-L3680","name":"Lean.scientificLitKind","docLink":"./Init/Prelude.html#Lean.scientificLitKind","doc":"`scientific` is the node kind of floating point literals like `1.23e-3`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3677-L3677","name":"Lean.numLitKind","docLink":"./Init/Prelude.html#Lean.numLitKind","doc":"`num` is the node kind of number literals like `42`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3674-L3674","name":"Lean.charLitKind","docLink":"./Init/Prelude.html#Lean.charLitKind","doc":"`char` is the node kind of character literals like `'A'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3671-L3671","name":"Lean.strLitKind","docLink":"./Init/Prelude.html#Lean.strLitKind","doc":"`str` is the node kind of string literals like `\"foo\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3668-L3668","name":"Lean.identKind","docLink":"./Init/Prelude.html#Lean.identKind","doc":"`ident` is not actually used as a node kind, but it is returned by\n`getKind` in the `ident` case so that things that handle different node\nkinds can also handle `ident`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3661-L3661","name":"Lean.groupKind","docLink":"./Init/Prelude.html#Lean.groupKind","doc":"The `group` kind is by the `group` parser, to avoid confusing with the null\nkind when used inside `optional`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3655-L3655","name":"Lean.nullKind","docLink":"./Init/Prelude.html#Lean.nullKind","doc":"The null kind is used for raw list parsers like `many`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3652-L3652","name":"Lean.choiceKind","docLink":"./Init/Prelude.html#Lean.choiceKind","doc":"The `choice` kind is used when a piece of syntax has multiple parses, and the\ndetermination of which to use is deferred until typing information is available.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3643-L3644","name":"Lean.instInhabitedTSyntax","docLink":"./Init/Prelude.html#Lean.instInhabitedTSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3640-L3641","name":"Lean.instInhabitedSyntax","docLink":"./Init/Prelude.html#Lean.instInhabitedSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3636-L3638","name":"Lean.TSyntax","docLink":"./Init/Prelude.html#Lean.TSyntax","doc":"A `Syntax` value of one of the given syntax kinds.\nNote that while syntax quotations produce/expect `TSyntax` values of the correct kinds,\nthis is not otherwise enforced and can easily be circumvented by direct use of the constructor.\nThe namespace `TSyntax.Compat` can be opened to expose a general coercion from `Syntax` to any\n`TSyntax ks` for porting older code.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3627-L3627","name":"Lean.SyntaxNodeKinds","docLink":"./Init/Prelude.html#Lean.SyntaxNodeKinds","doc":"`SyntaxNodeKinds` is a set of `SyntaxNodeKind` (implemented as a list). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3623-L3624","name":"Lean.Syntax.node8","docLink":"./Init/Prelude.html#Lean.Syntax.node8","doc":"Create syntax node with 8 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3619-L3620","name":"Lean.Syntax.node7","docLink":"./Init/Prelude.html#Lean.Syntax.node7","doc":"Create syntax node with 7 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3615-L3616","name":"Lean.Syntax.node6","docLink":"./Init/Prelude.html#Lean.Syntax.node6","doc":"Create syntax node with 6 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3611-L3612","name":"Lean.Syntax.node5","docLink":"./Init/Prelude.html#Lean.Syntax.node5","doc":"Create syntax node with 5 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3607-L3608","name":"Lean.Syntax.node4","docLink":"./Init/Prelude.html#Lean.Syntax.node4","doc":"Create syntax node with 4 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3603-L3604","name":"Lean.Syntax.node3","docLink":"./Init/Prelude.html#Lean.Syntax.node3","doc":"Create syntax node with 3 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3599-L3600","name":"Lean.Syntax.node2","docLink":"./Init/Prelude.html#Lean.Syntax.node2","doc":"Create syntax node with 2 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3595-L3596","name":"Lean.Syntax.node1","docLink":"./Init/Prelude.html#Lean.Syntax.node1","doc":"Create syntax node with 1 child "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3557-L3592","name":"Lean.Syntax","docLink":"./Init/Prelude.html#Lean.Syntax","doc":"Syntax objects used by the parser, macro expander, delaborator, etc.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3548-L3552","name":"Lean.Syntax.Preresolved","docLink":"./Init/Prelude.html#Lean.Syntax.Preresolved","doc":"Binding information resolved and stored at compile time of a syntax quotation.\nNote: We do not statically know whether a syntax expects a namespace or term name,\nso a `Syntax.ident` may contain both preresolution kinds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3539-L3539","name":"Lean.SyntaxNodeKind","docLink":"./Init/Prelude.html#Lean.SyntaxNodeKind","doc":"A `SyntaxNodeKind` classifies `Syntax.node` values. It is an abbreviation for\n`Name`, and you can use name literals to construct `SyntaxNodeKind`s, but\nthey need not refer to declarations in the environment. Conventionally, a\n`SyntaxNodeKind` will correspond to the `Parser` or `ParserDesc` declaration\nthat parses it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3523-L3528","name":"Lean.SourceInfo.getPos?","docLink":"./Init/Prelude.html#Lean.SourceInfo.getPos?","doc":"Gets the position information from a `SourceInfo`, if available.\nIf `originalOnly` is true, then `.synthetic` syntax will also return `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3515-L3515","name":"Lean.instInhabitedSourceInfo","docLink":"./Init/Prelude.html#Lean.instInhabitedSourceInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3481-L3513","name":"Lean.SourceInfo","docLink":"./Init/Prelude.html#Lean.SourceInfo","doc":"Source information of tokens. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3473-L3474","name":"Lean.Name.instAppendName","docLink":"./Init/Prelude.html#Lean.Name.instAppendName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3468-L3471","name":"Lean.Name.append","docLink":"./Init/Prelude.html#Lean.Name.append","doc":"Append two hierarchical names. Example:\n```lean\n`Lean.Meta ++ `Tactic.simp\n```\nreturn `Lean.Meta.Tactic.simp`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3458-L3459","name":"Lean.Name.instBEqName","docLink":"./Init/Prelude.html#Lean.Name.instBEqName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3452-L3456","name":"Lean.Name.beq","docLink":"./Init/Prelude.html#Lean.Name.beq","doc":"(Boolean) equality comparator for names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3447-L3448","name":"Lean.Name.mkStr8","docLink":"./Init/Prelude.html#Lean.Name.mkStr8","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆.s₇.s₈` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3443-L3444","name":"Lean.Name.mkStr7","docLink":"./Init/Prelude.html#Lean.Name.mkStr7","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆.s₇` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3439-L3440","name":"Lean.Name.mkStr6","docLink":"./Init/Prelude.html#Lean.Name.mkStr6","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3435-L3436","name":"Lean.Name.mkStr5","docLink":"./Init/Prelude.html#Lean.Name.mkStr5","doc":"Make name `s₁.s₂.s₃.s₄.s₅` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3431-L3432","name":"Lean.Name.mkStr4","docLink":"./Init/Prelude.html#Lean.Name.mkStr4","doc":"Make name `s₁.s₂.s₃.s₄` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3427-L3428","name":"Lean.Name.mkStr3","docLink":"./Init/Prelude.html#Lean.Name.mkStr3","doc":"Make name `s₁.s₂.s₃` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3423-L3424","name":"Lean.Name.mkStr2","docLink":"./Init/Prelude.html#Lean.Name.mkStr2","doc":"Make name `s₁.s₂` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3419-L3420","name":"Lean.Name.mkStr1","docLink":"./Init/Prelude.html#Lean.Name.mkStr1","doc":"Make name `s₁` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3415-L3416","name":"Lean.Name.mkSimple","docLink":"./Init/Prelude.html#Lean.Name.mkSimple","doc":"Short for `.str .anonymous s`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3409-L3410","name":"Lean.Name.mkNum","docLink":"./Init/Prelude.html#Lean.Name.mkNum","doc":"`.num p v` is now the preferred form.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3402-L3403","name":"Lean.Name.mkStr","docLink":"./Init/Prelude.html#Lean.Name.mkStr","doc":"`.str p s` is now the preferred form.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3393-L3394","name":"Lean.instHashableName","docLink":"./Init/Prelude.html#Lean.instHashableName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3390-L3391","name":"Lean.instInhabitedName","docLink":"./Init/Prelude.html#Lean.instInhabitedName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3364-L3388","name":"Lean.Name","docLink":"./Init/Prelude.html#Lean.Name","doc":"Hierarchical names. We use hierarchical names to name declarations and\nfor creating unique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using the following quotation notation.\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`\nYou can use double quotes to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3348-L3388","name":"Lean.Name.hash","docLink":"./Init/Prelude.html#Lean.Name.hash","doc":"A hash function for names, which is stored inside the name itself as a\ncomputed field. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3343-L3344","name":"instHashableString","docLink":"./Init/Prelude.html#instHashableString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3341-L3341","name":"String.hash","docLink":"./Init/Prelude.html#String.hash","doc":"A opaque string hash function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3336-L3337","name":"instHashableSubtype","docLink":"./Init/Prelude.html#instHashableSubtype","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3334-L3334","name":"mixHash","docLink":"./Init/Prelude.html#mixHash","doc":"An opaque hash mixing operation, used to implement hashing for tuples. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3321-L3330","name":"USize.toUInt64","docLink":"./Init/Prelude.html#USize.toUInt64","doc":"Upcast a `USize` to a `UInt64`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3313-L3313","name":"UInt64.toUSize","docLink":"./Init/Prelude.html#UInt64.toUSize","doc":"Converts a `UInt64` to a `USize` by reducing modulo `USize.size`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3305-L3307","name":"Hashable","docLink":"./Init/Prelude.html#Hashable","doc":"A class for types that can be hashed into a `UInt64`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3298-L3300","name":"EStateM.nonBacktrackable","docLink":"./Init/Prelude.html#EStateM.nonBacktrackable","doc":"Dummy default instance. This makes every `σ` trivially \"backtrackable\"\nby doing nothing on backtrack. Because this is the first declared instance\nof `Backtrackable _ σ`, it will be picked only if there are no other\n`Backtrackable _ σ` instances registered.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3290-L3290","name":"EStateM.dummyRestore","docLink":"./Init/Prelude.html#EStateM.dummyRestore","doc":"The `restore` implementation for `Backtrackable PUnit σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3287-L3287","name":"EStateM.dummySave","docLink":"./Init/Prelude.html#EStateM.dummySave","doc":"The `save` implementation for `Backtrackable PUnit σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3281-L3284","name":"EStateM.run'","docLink":"./Init/Prelude.html#EStateM.run'","doc":"Execute an `EStateM` on initial state `s` for the returned value `α`.\nIf the monadic action throws an exception, returns `none` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3274-L3274","name":"EStateM.run","docLink":"./Init/Prelude.html#EStateM.run","doc":"Execute an `EStateM` on initial state `s` to get a `Result`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3268-L3270","name":"EStateM.instMonadExceptOfEStateM","docLink":"./Init/Prelude.html#EStateM.instMonadExceptOfEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3263-L3266","name":"EStateM.instMonadStateOfEStateM","docLink":"./Init/Prelude.html#EStateM.instMonadStateOfEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3260-L3261","name":"EStateM.instOrElseEStateM","docLink":"./Init/Prelude.html#EStateM.instOrElseEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3254-L3258","name":"EStateM.instMonadEStateM","docLink":"./Init/Prelude.html#EStateM.instMonadEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3248-L3251","name":"EStateM.seqRight","docLink":"./Init/Prelude.html#EStateM.seqRight","doc":"The `seqRight` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3241-L3244","name":"EStateM.map","docLink":"./Init/Prelude.html#EStateM.map","doc":"The `map` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3234-L3237","name":"EStateM.bind","docLink":"./Init/Prelude.html#EStateM.bind","doc":"The `bind` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3227-L3230","name":"EStateM.adaptExcept","docLink":"./Init/Prelude.html#EStateM.adaptExcept","doc":"Map the exception type of a `EStateM ε σ α` by a function `f : ε → ε'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3219-L3223","name":"EStateM.orElse","docLink":"./Init/Prelude.html#EStateM.orElse","doc":"Implementation of `orElse` for `EStateM` where the state is `Backtrackable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3211-L3215","name":"EStateM.tryCatch","docLink":"./Init/Prelude.html#EStateM.tryCatch","doc":"Implementation of `tryCatch` for `EStateM` where the state is `Backtrackable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3202-L3207","name":"EStateM.Backtrackable","docLink":"./Init/Prelude.html#EStateM.Backtrackable","doc":"Auxiliary instance for saving/restoring the \"backtrackable\" part of the state.\nHere `σ` is the state, and `δ` is some subpart of it, and we have a\ngetter and setter for it (a \"lens\" in the Haskell terminology).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3194-L3195","name":"EStateM.throw","docLink":"./Init/Prelude.html#EStateM.throw","doc":"The `throw` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3188-L3190","name":"EStateM.modifyGet","docLink":"./Init/Prelude.html#EStateM.modifyGet","doc":"The `modifyGet` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3183-L3184","name":"EStateM.get","docLink":"./Init/Prelude.html#EStateM.get","doc":"The `get` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3178-L3179","name":"EStateM.set","docLink":"./Init/Prelude.html#EStateM.set","doc":"The `set` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3173-L3174","name":"EStateM.pure","docLink":"./Init/Prelude.html#EStateM.pure","doc":"The `pure` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3168-L3169","name":"EStateM.instInhabitedEStateM","docLink":"./Init/Prelude.html#EStateM.instInhabitedEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3162-L3162","name":"EStateM","docLink":"./Init/Prelude.html#EStateM","doc":"`EStateM ε σ` is a combined error and state monad, equivalent to\n`ExceptT ε (StateM σ)` but more efficient.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3152-L3153","name":"EStateM.instInhabitedResult","docLink":"./Init/Prelude.html#EStateM.instInhabitedResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3144-L3148","name":"EStateM.Result","docLink":"./Init/Prelude.html#EStateM.Result","doc":"`Result ε σ α` is equivalent to `Except ε α × σ`, but using a single\ncombined inductive yields a more efficient data representation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3133-L3136","name":"instMonadStateOf","docLink":"./Init/Prelude.html#instMonadStateOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3127-L3128","name":"getModify","docLink":"./Init/Prelude.html#getModify","doc":"`getModify f` gets the state, applies function `f`, and returns the old value\nof the state. It is equivalent to `get <* modify f` but may be more efficient.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3119-L3120","name":"modify","docLink":"./Init/Prelude.html#modify","doc":"`modify (f : σ → σ)` applies the function `f` to the state.\n\nIt is equivalent to `do put (f (← get))`, but `modify f` may be preferable\nbecause the former does not use the state linearly (without sufficient inlining).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3107-L3110","name":"instMonadState","docLink":"./Init/Prelude.html#instMonadState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3092-L3103","name":"MonadState","docLink":"./Init/Prelude.html#MonadState","doc":"Similar to `MonadStateOf`, but `σ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3088-L3089","name":"modifyGetThe","docLink":"./Init/Prelude.html#modifyGetThe","doc":"Like `modifyGet`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3080-L3081","name":"modifyThe","docLink":"./Init/Prelude.html#modifyThe","doc":"Like `modify`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3072-L3073","name":"getThe","docLink":"./Init/Prelude.html#getThe","doc":"Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3053-L3064","name":"MonadStateOf","docLink":"./Init/Prelude.html#MonadStateOf","doc":"An implementation of [`MonadState`]. In contrast to the Haskell implementation,\nwe use overlapping instances to derive instances automatically from `monadLift`.\n\n  [`MonadState`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3044-L3045","name":"instMonadWithReaderOfReaderT","docLink":"./Init/Prelude.html#instMonadWithReaderOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3041-L3042","name":"instMonadWithReaderOf","docLink":"./Init/Prelude.html#instMonadWithReaderOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3038-L3039","name":"instMonadWithReader","docLink":"./Init/Prelude.html#instMonadWithReader","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3031-L3034","name":"MonadWithReader","docLink":"./Init/Prelude.html#MonadWithReader","doc":"Similar to `MonadWithReaderOf`, but `ρ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3027-L3028","name":"withTheReader","docLink":"./Init/Prelude.html#withTheReader","doc":"Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3017-L3020","name":"MonadWithReaderOf","docLink":"./Init/Prelude.html#MonadWithReaderOf","doc":"`MonadWithReaderOf ρ` adds the operation `withReader : (ρ → ρ) → m α → m α`.\nThis runs the inner `x : m α` inside a modified context after applying the\nfunction `f : ρ → ρ`. In addition to `ReaderT` itself, this operation lifts\nover most monad transformers, so it allows us to apply `withReader` to monads\ndeeper in the stack.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3007-L3008","name":"instMonadReaderOfReaderT","docLink":"./Init/Prelude.html#instMonadReaderOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3004-L3005","name":"instMonadReaderOf","docLink":"./Init/Prelude.html#instMonadReaderOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L3001-L3002","name":"instMonadReader","docLink":"./Init/Prelude.html#instMonadReader","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2995-L2997","name":"MonadReader","docLink":"./Init/Prelude.html#MonadReader","doc":"Similar to `MonadReaderOf`, but `ρ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2991-L2992","name":"readThe","docLink":"./Init/Prelude.html#readThe","doc":"Like `read`, but with `ρ` explicit. This is useful if a monad supports\n`MonadReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2982-L2984","name":"MonadReaderOf","docLink":"./Init/Prelude.html#MonadReaderOf","doc":"An implementation of [`MonadReader`]. It does not contain `local` because this\nfunction cannot be lifted using `monadLift`. Instead, the `MonadReaderAdapter`\nclass provides the more general `adaptReader` function.\n\nNote: This class can be seen as a simplification of the more \"principled\" definition\n```\nclass MonadReaderOf (ρ : Type u) (n : Type u → Type u) where\n  lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → ReaderT ρ m α) → n α\n```\n\n  [`MonadReader`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2963-L2964","name":"ReaderT.adapt","docLink":"./Init/Prelude.html#ReaderT.adapt","doc":"`adapt (f : ρ' → ρ)` precomposes function `f` on the reader state of a\n`ReaderT ρ`, yielding a `ReaderT ρ'`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2955-L2956","name":"ReaderT.instMonadFunctorReaderT","docLink":"./Init/Prelude.html#ReaderT.instMonadFunctorReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2952-L2953","name":"ReaderT.instMonadReaderT","docLink":"./Init/Prelude.html#ReaderT.instMonadReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2946-L2950","name":"ReaderT.instApplicativeReaderT","docLink":"./Init/Prelude.html#ReaderT.instApplicativeReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2941-L2943","name":"ReaderT.instFunctorReaderT","docLink":"./Init/Prelude.html#ReaderT.instFunctorReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2937-L2938","name":"ReaderT.bind","docLink":"./Init/Prelude.html#ReaderT.bind","doc":"The `bind` operation of the `ReaderT` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2932-L2933","name":"ReaderT.pure","docLink":"./Init/Prelude.html#ReaderT.pure","doc":"The `pure` operation of the `ReaderT` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2927-L2928","name":"ReaderT.read","docLink":"./Init/Prelude.html#ReaderT.read","doc":"`(← read) : ρ` gets the read-only state of a `ReaderT ρ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2916-L2918","name":"ReaderT.instMonadExceptOfReaderT","docLink":"./Init/Prelude.html#ReaderT.instMonadExceptOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2912-L2913","name":"ReaderT.instMonadLiftReaderT","docLink":"./Init/Prelude.html#ReaderT.instMonadLiftReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2904-L2905","name":"ReaderT.run","docLink":"./Init/Prelude.html#ReaderT.run","doc":"If `x : ReaderT ρ m α` and `r : ρ`, then `x.run r : ρ` runs the monad with the\ngiven reader state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2896-L2897","name":"instInhabitedReaderT","docLink":"./Init/Prelude.html#instInhabitedReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2893-L2894","name":"ReaderT","docLink":"./Init/Prelude.html#ReaderT","doc":"An implementation of Haskell's [`ReaderT`]. This is a monad transformer which\nequips a monad with additional read-only state, of type `ρ`.\n\n  [`ReaderT`]: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2882-L2883","name":"MonadExcept.instOrElse","docLink":"./Init/Prelude.html#MonadExcept.instOrElse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2879-L2880","name":"MonadExcept.orElse","docLink":"./Init/Prelude.html#MonadExcept.orElse","doc":"A `MonadExcept` can implement `t₁ <|> t₂` as `try t₁ catch _ => t₂`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2871-L2873","name":"instMonadExcept","docLink":"./Init/Prelude.html#instMonadExcept","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2865-L2867","name":"MonadExcept.ofExcept","docLink":"./Init/Prelude.html#MonadExcept.ofExcept","doc":"\"Unwraps\" an `Except ε α` to get the `α`, or throws the exception otherwise. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2855-L2862","name":"MonadExcept","docLink":"./Init/Prelude.html#MonadExcept","doc":"Similar to `MonadExceptOf`, but `ε` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2851-L2852","name":"tryCatchThe","docLink":"./Init/Prelude.html#tryCatchThe","doc":"This is the same as `tryCatch`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2844-L2845","name":"throwThe","docLink":"./Init/Prelude.html#throwThe","doc":"This is the same as `throw`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2831-L2838","name":"MonadExceptOf","docLink":"./Init/Prelude.html#MonadExceptOf","doc":"An implementation of Haskell's [`MonadError`] class. A `MonadError ε m` is a\nmonad `m` with two operations:\n\n* `throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\n  catch block\n* `tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n  `body` and pass the resulting error to `handler`.\n  Errors in `handler` will not be caught.\n\nThe `try ... catch e => ...` syntax inside `do` blocks is sugar for the\n`tryCatch` operation.\n\n  [`MonadError`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2813-L2814","name":"instInhabitedExcept","docLink":"./Init/Prelude.html#instInhabitedExcept","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2805-L2809","name":"Except","docLink":"./Init/Prelude.html#Except","doc":"`Except ε α` is a type which represents either an error of type `ε`, or an \"ok\"\nvalue of type `α`. The error type is listed first because\n`Except ε : Type → Type` is a `Monad`: the pure operation is `ok` and the bind\noperation returns the first encountered `error`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2796-L2797","name":"monadFunctorRefl","docLink":"./Init/Prelude.html#monadFunctorRefl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2793-L2794","name":"instMonadFunctorT","docLink":"./Init/Prelude.html#instMonadFunctorT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2785-L2788","name":"MonadFunctorT","docLink":"./Init/Prelude.html#MonadFunctorT","doc":"The reflexive-transitive closure of `MonadFunctor`.\n`monadMap` is used to transitively lift `Monad` morphisms. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2778-L2781","name":"MonadFunctor","docLink":"./Init/Prelude.html#MonadFunctor","doc":"A functor in the category of monads. Can be used to lift monad-transforming functions.\nBased on [`MFunctor`] from the `pipes` Haskell package, but not restricted to\nmonad transformers. Alternatively, an implementation of [`MonadTransFunctor`].\n\n  [`MFunctor`]: https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html\n  [`MonadTransFunctor`]: http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2767-L2768","name":"instMonadLiftT_1","docLink":"./Init/Prelude.html#instMonadLiftT_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2764-L2765","name":"instMonadLiftT","docLink":"./Init/Prelude.html#instMonadLiftT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2761-L2761","name":"liftM","docLink":"./Init/Prelude.html#liftM","doc":"Lifts a value from monad `m` into monad `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2754-L2756","name":"MonadLiftT","docLink":"./Init/Prelude.html#MonadLiftT","doc":"The reflexive-transitive closure of `MonadLift`. `monadLift` is used to\ntransitively lift monadic computations such as `StateT.get` or `StateT.put s`.\nCorresponds to Haskell's [`MonadLift`].\n\n  [`MonadLift`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2743-L2745","name":"MonadLift","docLink":"./Init/Prelude.html#MonadLift","doc":"A function for lifting a computation from an inner `Monad` to an outer `Monad`.\nLike Haskell's [`MonadTrans`], but `n` does not have to be a monad transformer.\nAlternatively, an implementation of [`MonadLayer`] without `layerInvmap` (so far).\n\n  [`MonadTrans`]: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html\n  [`MonadLayer`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2726-L2732","name":"Array.sequenceMap.loop","docLink":"./Init/Prelude.html#Array.sequenceMap.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2725-L2733","name":"Array.sequenceMap","docLink":"./Init/Prelude.html#Array.sequenceMap","doc":"A fusion of Haskell's `sequence` and `map`. Used in syntax quotations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2721-L2722","name":"instForAllNonemptyNonempty","docLink":"./Init/Prelude.html#instForAllNonemptyNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2718-L2719","name":"instInhabited","docLink":"./Init/Prelude.html#instInhabited","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2715-L2716","name":"instInhabitedForAll_2","docLink":"./Init/Prelude.html#instInhabitedForAll_2","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2709-L2713","name":"Monad","docLink":"./Init/Prelude.html#Monad","doc":"A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a\nstructure which abstracts the concept of sequential control flow.\nIt mainly consists of two operations:\n\n* `pure : α → F α`\n* `bind : F α → (α → F β) → F β` (written as `>>=`)\n\nLike many functional programming languages, Lean makes extensive use of monads\nfor structuring programs. In particular, the `do` notation is a very powerful\nsyntax over monad operations, and it depends on a `Monad` instance.\n\nSee [the `do` notation](https://leanprover.github.io/lean4/doc/do.html)\nchapter of the manual for details.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2689-L2692","name":"Applicative","docLink":"./Init/Prelude.html#Applicative","doc":"An [applicative functor](https://en.wikipedia.org/wiki/Applicative_functor) is\nan intermediate structure between `Functor` and `Monad`. It mainly consists of\ntwo operations:\n\n* `pure : α → F α`\n* `seq : F (α → β) → F α → F β` (written as `<*>`)\n\nThe `seq` operator gives a notion of evaluation order to the effects, where\nthe first argument is executed before the second, but unlike a monad the results\nof earlier computations cannot be used to define later actions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2669-L2675","name":"SeqRight","docLink":"./Init/Prelude.html#SeqRight","doc":"The typeclass which supplies the `*>` \"seqRight\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2660-L2666","name":"SeqLeft","docLink":"./Init/Prelude.html#SeqLeft","doc":"The typeclass which supplies the `<*` \"seqLeft\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2650-L2657","name":"Seq","docLink":"./Init/Prelude.html#Seq","doc":"The typeclass which supplies the `<*>` \"seq\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2642-L2647","name":"Functor","docLink":"./Init/Prelude.html#Functor","doc":"In functional programming, a \"functor\" is a function on types `F : Type u → Type v`\nequipped with an operator called `map` or `<$>` such that if `f : α → β` then\n`map f : F α → F β`, so `f <$> x : F β` if `x : F α`. This corresponds to the\ncategory-theory notion of [functor](https://en.wikipedia.org/wiki/Functor) in\nthe special case where the category is the category of types and functions\nbetween them, except that this class supplies only the operations and not the\nlaws (see `LawfulFunctor`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2626-L2629","name":"Pure","docLink":"./Init/Prelude.html#Pure","doc":"The typeclass which supplies the `pure` function. See `Monad`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2618-L2621","name":"Bind","docLink":"./Init/Prelude.html#Bind","doc":"The typeclass which supplies the `>>=` \"bind\" function. See `Monad`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2614-L2615","name":"List.toArray","docLink":"./Init/Prelude.html#List.toArray","doc":"Convert a `List α` into an `Array α`. This is O(n) in the length of the list.\n\nThis function is exported to C, where it is called by `Array.mk`\n(the constructor) to implement this functionality.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2603-L2605","name":"List.redLength","docLink":"./Init/Prelude.html#List.redLength","doc":"A non-tail-recursive version of `List.length`, used for `List.toArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2597-L2599","name":"List.toArrayAux","docLink":"./Init/Prelude.html#List.toArrayAux","doc":"Auxiliary definition for `List.toArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2586-L2592","name":"Array.appendCore.loop","docLink":"./Init/Prelude.html#Array.appendCore.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2585-L2593","name":"Array.appendCore","docLink":"./Init/Prelude.html#Array.appendCore","doc":"Slower `Array.append` used in quotations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2581-L2582","name":"Array.set!","docLink":"./Init/Prelude.html#Array.set!","doc":"Set an element in an array, or panic if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2571-L2572","name":"Array.setD","docLink":"./Init/Prelude.html#Array.setD","doc":"Set an element in an array, or do nothing if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2562-L2563","name":"Array.set","docLink":"./Init/Prelude.html#Array.set","doc":"Set an element in an array without bounds checks, using a `Fin` index.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2552-L2553","name":"Array.mkArray8","docLink":"./Init/Prelude.html#Array.mkArray8","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2548-L2549","name":"Array.mkArray7","docLink":"./Init/Prelude.html#Array.mkArray7","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2544-L2545","name":"Array.mkArray6","docLink":"./Init/Prelude.html#Array.mkArray6","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2540-L2541","name":"Array.mkArray5","docLink":"./Init/Prelude.html#Array.mkArray5","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2536-L2537","name":"Array.mkArray4","docLink":"./Init/Prelude.html#Array.mkArray4","doc":"Create array `#[a₁, a₂, a₃, a₄]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2532-L2533","name":"Array.mkArray3","docLink":"./Init/Prelude.html#Array.mkArray3","doc":"Create array `#[a₁, a₂, a₃]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2528-L2529","name":"Array.mkArray2","docLink":"./Init/Prelude.html#Array.mkArray2","doc":"Create array `#[a₁, a₂]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2524-L2525","name":"Array.mkArray1","docLink":"./Init/Prelude.html#Array.mkArray1","doc":"Create array `#[a₁]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2520-L2521","name":"Array.mkArray0","docLink":"./Init/Prelude.html#Array.mkArray0","doc":"Create array `#[]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2516-L2517","name":"Array.push","docLink":"./Init/Prelude.html#Array.push","doc":"Push an element onto the end of an array. This is amortized O(1) because\n`Array α` is internally a dynamic array.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2508-L2509","name":"instGetElemArrayNatLtInstLTNatSize","docLink":"./Init/Prelude.html#instGetElemArrayNatLtInstLTNatSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2505-L2506","name":"Array.get!","docLink":"./Init/Prelude.html#Array.get!","doc":"Access an element from an array, or panic if the index is out of bounds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2500-L2501","name":"Array.getD","docLink":"./Init/Prelude.html#Array.getD","doc":"Access an element from an array, or return `v₀` if the index is out of bounds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2496-L2497","name":"Array.get","docLink":"./Init/Prelude.html#Array.get","doc":"Access an element from an array without bounds checks, using a `Fin` index. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2491-L2492","name":"Array.size","docLink":"./Init/Prelude.html#Array.size","doc":"Get the size of an array. This is a cached value, so it is O(1) to access. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2487-L2487","name":"Array.empty","docLink":"./Init/Prelude.html#Array.empty","doc":"Construct a new empty array. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2483-L2484","name":"Array.mkEmpty","docLink":"./Init/Prelude.html#Array.mkEmpty","doc":"Construct a new empty array with initial capacity `c`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2470-L2476","name":"Array","docLink":"./Init/Prelude.html#Array","doc":"`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nwith elements from `α`. This type has special support in the runtime.\n\nAn array has a size and a capacity; the size is `Array.size` but the capacity\nis not observable from lean code. Arrays perform best when unshared; as long\nas they are used \"linearly\" all updates will be performed destructively on the\narray, so it has comparable performance to mutable arrays in imperative\nprogramming languages.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2435-L2456","name":"GetElem","docLink":"./Init/Prelude.html#GetElem","doc":"The class `GetElem cont idx elem dom` implements the `xs[i]` notation.\nWhen you write this, given `xs : cont` and `i : idx`, lean looks for an instance\nof `GetElem cont idx elem dom`. Here `elem` is the type of `xs[i]`, while\n`dom` is whatever proof side conditions are required to make this applicable.\nFor example, the instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i => i < xs.size)`.\n\nThe proof side-condition `dom xs i` is automatically dispatched by the\n`get_elem_tactic` tactic, which can be extended by adding more clauses to\n`get_elem_tactic_trivial`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2417-L2418","name":"panic","docLink":"./Init/Prelude.html#panic","doc":"`(panic \"msg\" : α)` has a built-in implementation which prints `msg` to\nthe error buffer. It *does not* terminate execution, and because it is a safe\nfunction, it still has to return an element of `α`, so it takes `[Inhabited α]`\nand returns `default`. It is primarily intended for debugging in pure contexts,\nand assertion failures.\n\nBecause this is a pure function with side effects, it is marked as\n`@[never_extract]` so that the compiler will not perform common sub-expression\nelimination and other optimizations that assume that the expression is pure.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2403-L2403","name":"panicCore","docLink":"./Init/Prelude.html#panicCore","doc":"Auxiliary definition for `panic`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2387-L2388","name":"unsafeCast","docLink":"./Init/Prelude.html#unsafeCast","doc":"This function will cast a value of type `α` to type `β`, and is a no-op in the\ncompiler. This function is **extremely dangerous** because there is no guarantee\nthat types `α` and `β` have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\n`True` to `False`. For all those reasons this function is marked as `unsafe`.\n\nIt is implemented by lifting both `α` and `β` into a common universe, and then\nusing `cast (lcProof : ULift (PLift α) = ULift (PLift β))` to actually perform\nthe cast. All these operations are no-ops in the compiler.\n\nUsing this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:\n\n* `Array α` to `Array β` where `α` and `β` have compatible representations,\n  or more generally for other inductive types.\n* `Quot α r` and `α`.\n* `@Subtype α p` and `α`, or generally any structure containing only one\n  non-`Prop` field of type `α`.\n* Casting `α` to/from `NonScalar` when `α` is a boxed generic type\n  (i.e. a function that accepts an arbitrary type `α` and is not specialized to\n  a scalar type like `UInt8`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2360-L2361","name":"String.toSubstring'","docLink":"./Init/Prelude.html#String.toSubstring'","doc":"`String.toSubstring` without `[inline]` annotation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2354-L2357","name":"String.toSubstring","docLink":"./Init/Prelude.html#String.toSubstring","doc":"Convert a `String` into a `Substring` denoting the entire string. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2350-L2351","name":"String.endPos","docLink":"./Init/Prelude.html#String.endPos","doc":"A `String.Pos` pointing at the end of this string. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2346-L2347","name":"instDecidableLtPosInstLTPos","docLink":"./Init/Prelude.html#instDecidableLtPosInstLTPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2343-L2344","name":"instDecidableLePosInstLEPos","docLink":"./Init/Prelude.html#instDecidableLePosInstLEPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2340-L2341","name":"instLTPos","docLink":"./Init/Prelude.html#instLTPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2337-L2338","name":"instLEPos","docLink":"./Init/Prelude.html#instLEPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2334-L2335","name":"instHAddPosString","docLink":"./Init/Prelude.html#instHAddPosString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2331-L2332","name":"instHAddPosChar","docLink":"./Init/Prelude.html#instHAddPosChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2328-L2329","name":"instHSubPos","docLink":"./Init/Prelude.html#instHSubPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2325-L2326","name":"instHAddPos","docLink":"./Init/Prelude.html#instHAddPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2321-L2323","name":"String.utf8ByteSize.go","docLink":"./Init/Prelude.html#String.utf8ByteSize.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2318-L2323","name":"String.utf8ByteSize","docLink":"./Init/Prelude.html#String.utf8ByteSize","doc":"The UTF-8 byte length of this string.\nThis is overridden by the compiler to be cached and O(1).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2310-L2311","name":"String.csize","docLink":"./Init/Prelude.html#String.csize","doc":"Returns the number of bytes required to encode this `Char` in UTF-8. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2306-L2307","name":"Substring.bsize","docLink":"./Init/Prelude.html#Substring.bsize","doc":"The byte length of the substring. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2302-L2303","name":"instInhabitedSubstring","docLink":"./Init/Prelude.html#instInhabitedSubstring","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2294-L2300","name":"Substring","docLink":"./Init/Prelude.html#Substring","doc":"A `Substring` is a view into some subslice of a `String`.\nThe actual string slicing is deferred because this would require copying the\nstring; here we only store a reference to the original string for\ngarbage collection purposes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2283-L2286","name":"instDecidableEqPos","docLink":"./Init/Prelude.html#instDecidableEqPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2280-L2281","name":"instInhabitedPos","docLink":"./Init/Prelude.html#instInhabitedPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2276-L2278","name":"String.Pos","docLink":"./Init/Prelude.html#String.Pos","doc":"A byte position in a `String`. Internally, `String`s are UTF-8 encoded.\nCodepoint positions (counting the Unicode codepoints rather than bytes)\nare represented by plain `Nat`s instead.\nIndexing a `String` by a byte position is constant-time, while codepoint\npositions need to be translated internally to byte positions in linear-time.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2267-L2267","name":"instDecidableEqString","docLink":"./Init/Prelude.html#instDecidableEqString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2262-L2265","name":"String.decEq","docLink":"./Init/Prelude.html#String.decEq","doc":"Decides equality on `String`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2246-L2252","name":"String","docLink":"./Init/Prelude.html#String","doc":"`String` is the type of (UTF-8 encoded) strings.\n\nThe compiler overrides the data representation of this type to a byte sequence,\nand both `String.utf8ByteSize` and `String.length` are cached and O(1).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2236-L2238","name":"List.get","docLink":"./Init/Prelude.html#List.get","doc":"`as.get i` returns the `i`'th element of the list `as`.\nThis version of the function uses `i : Fin as.length` to ensure that it will\nnot index out of bounds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2227-L2229","name":"List.concat","docLink":"./Init/Prelude.html#List.concat","doc":"`l.concat a` appends `a` at the *end* of `l`, that is, `l ++ [a]`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2223-L2224","name":"List.length_cons","docLink":"./Init/Prelude.html#List.length_cons","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2220-L2221","name":"List.lengthTR","docLink":"./Init/Prelude.html#List.lengthTR","doc":"A tail-recursive version of `List.length`, used to implement `List.length`\nwithout running out of stack space.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2212-L2214","name":"List.lengthTRAux","docLink":"./Init/Prelude.html#List.lengthTRAux","doc":"Auxiliary function for `List.lengthTR`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2207-L2209","name":"List.length","docLink":"./Init/Prelude.html#List.length","doc":"The length of a list: `[].length = 0` and `(a :: l).length = l.length + 1`.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant\nstack space, while leaving this function to use the \"naive\" recursion which is\neasier for reasoning.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2195-L2198","name":"List.set","docLink":"./Init/Prelude.html#List.set","doc":"`l.set n a` sets the value of list `l` at (zero-based) index `n` to `a`:\n`[a, b, c, d].set 1 b' = [a, b', c, d]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2187-L2189","name":"List.foldl","docLink":"./Init/Prelude.html#List.foldl","doc":"Folds a function over a list from the left:\n`foldl f z [a, b, c] = f (f (f z a) b) c`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2180-L2180","name":"instDecidableEqList","docLink":"./Init/Prelude.html#instDecidableEqList","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2168-L2178","name":"List.hasDecEq","docLink":"./Init/Prelude.html#List.hasDecEq","doc":"Implements decidable equality for `List α`, assuming `α` has decidable equality. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2164-L2165","name":"instInhabitedList","docLink":"./Init/Prelude.html#instInhabitedList","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2157-L2162","name":"List","docLink":"./Init/Prelude.html#List","doc":"`List α` is the type of ordered lists with elements of type `α`.\nIt is implemented as a linked list.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and\n  `Array α` is modeled as a wrapper around `List α`\n* `List α` works well as a persistent data structure, when many copies of the\n  tail are shared. When the value is not shared, `Array α` will have better\n  performance because it can do destructive updates.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2142-L2144","name":"Option.map","docLink":"./Init/Prelude.html#Option.map","doc":"Map a function over an `Option` by applying the function to the contained\nvalue if present.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2134-L2136","name":"Option.getD","docLink":"./Init/Prelude.html#Option.getD","doc":"Get with default. If `opt : Option α` and `dflt : α`, then `opt.getD dflt`\nreturns `a` if `opt = some a` and `dflt` otherwise.\n\nThis function is `@[macro_inline]`, so `dflt` will not be evaluated unless\n`opt` turns out to be `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2124-L2125","name":"instInhabitedOption","docLink":"./Init/Prelude.html#instInhabitedOption","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2114-L2118","name":"Option","docLink":"./Init/Prelude.html#Option","doc":"`Option α` is the type of values which are either `some a` for some `a : α`,\nor `none`. In functional programming languages, this type is used to represent\nthe possibility of failure, or sometimes nullability.\n\nFor example, the function `HashMap.find? : HashMap α β → α → Option β` looks up\na specified key `a : α` inside the map. Because we do not know in advance\nwhether the key is actually in the map, the return type is `Option β`, where\n`none` means the value was not in the map, and `some b` means that the value\nwas found and `b` is the value retrieved.\n\nTo extract a value from an `Option α`, we use pattern matching:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  match x with\n  | some a => some (f a)\n  | none => none\n```\nWe can also use `if let` to pattern match on `Option` and get the value\nin the branch:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  if let some a := x then\n    some (f a)\n  else\n    none\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2076-L2084","name":"Char.utf8Size","docLink":"./Init/Prelude.html#Char.utf8Size","doc":"Returns the number of bytes required to encode this `Char` in UTF-8. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2069-L2073","name":"instDecidableEqChar","docLink":"./Init/Prelude.html#instDecidableEqChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2066-L2067","name":"Char.val_ne_of_ne","docLink":"./Init/Prelude.html#Char.val_ne_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2063-L2064","name":"Char.ne_of_val_ne","docLink":"./Init/Prelude.html#Char.ne_of_val_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2060-L2061","name":"Char.val_eq_of_eq","docLink":"./Init/Prelude.html#Char.val_eq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2057-L2058","name":"Char.eq_of_val_eq","docLink":"./Init/Prelude.html#Char.eq_of_val_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2052-L2055","name":"Char.ofNat","docLink":"./Init/Prelude.html#Char.ofNat","doc":"Convert a `Nat` into a `Char`. If the `Nat` does not encode a valid unicode scalar value,\n`'\\0'` is returned instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2044-L2045","name":"Char.ofNatAux","docLink":"./Init/Prelude.html#Char.ofNatAux","doc":"Pack a `Nat` encoding a valid codepoint into a `Char`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2028-L2032","name":"Char","docLink":"./Init/Prelude.html#Char","doc":"The `Char` Type represents an unicode scalar value.\nSee http://www.unicode.org/glossary/#unicode_scalar_value). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2023-L2024","name":"UInt32.isValidChar","docLink":"./Init/Prelude.html#UInt32.isValidChar","doc":"A `UInt32` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2016-L2017","name":"Nat.isValidChar","docLink":"./Init/Prelude.html#Nat.isValidChar","doc":"A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L2004-L2010","name":"USize.ofNat32","docLink":"./Init/Prelude.html#USize.ofNat32","doc":"Upcast a `Nat` less than `2^32` to a `USize`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1993-L1996","name":"instInhabitedUSize","docLink":"./Init/Prelude.html#instInhabitedUSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1991-L1991","name":"instDecidableEqUSize","docLink":"./Init/Prelude.html#instDecidableEqUSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1986-L1989","name":"USize.decEq","docLink":"./Init/Prelude.html#USize.decEq","doc":"Decides equality on `USize`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1976-L1978","name":"USize.ofNatCore","docLink":"./Init/Prelude.html#USize.ofNatCore","doc":"Pack a `Nat` less than `USize.size` into a `USize`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1963-L1966","name":"USize","docLink":"./Init/Prelude.html#USize","doc":"A `USize` is an unsigned integer with the size of a word\nfor the platform's architecture.\n\nFor example, if running on a 32-bit machine, USize is equivalent to UInt32.\nOr on a 64-bit machine, UInt64.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1950-L1954","name":"usize_size_eq","docLink":"./Init/Prelude.html#usize_size_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1948-L1948","name":"USize.size","docLink":"./Init/Prelude.html#USize.size","doc":"The size of type `UInt16`, that is, `2^System.Platform.numBits`, which may\nbe either `2^32` or `2^64` depending on the platform's architecture.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1941-L1942","name":"instInhabitedUInt64","docLink":"./Init/Prelude.html#instInhabitedUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1939-L1939","name":"instDecidableEqUInt64","docLink":"./Init/Prelude.html#instDecidableEqUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1934-L1937","name":"UInt64.decEq","docLink":"./Init/Prelude.html#UInt64.decEq","doc":"Decides equality on `UInt64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1925-L1926","name":"UInt64.ofNatCore","docLink":"./Init/Prelude.html#UInt64.ofNatCore","doc":"Pack a `Nat` less than `2^64` into a `UInt64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1912-L1915","name":"UInt64","docLink":"./Init/Prelude.html#UInt64","doc":"The type of unsigned 64-bit integers. This type has special support in the\ncompiler to make it actually 64 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1907-L1907","name":"UInt64.size","docLink":"./Init/Prelude.html#UInt64.size","doc":"The size of type `UInt64`, that is, `2^64 = 18446744073709551616`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1904-L1904","name":"instMinUInt32","docLink":"./Init/Prelude.html#instMinUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1903-L1903","name":"instMaxUInt32","docLink":"./Init/Prelude.html#instMaxUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1902-L1902","name":"instDecidableLeUInt32InstLEUInt32","docLink":"./Init/Prelude.html#instDecidableLeUInt32InstLEUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1901-L1901","name":"instDecidableLtUInt32InstLTUInt32","docLink":"./Init/Prelude.html#instDecidableLtUInt32InstLTUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1897-L1899","name":"UInt32.decLe","docLink":"./Init/Prelude.html#UInt32.decLe","doc":"Decides less-than on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1887-L1889","name":"UInt32.decLt","docLink":"./Init/Prelude.html#UInt32.decLt","doc":"Decides less-equal on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1878-L1879","name":"instLEUInt32","docLink":"./Init/Prelude.html#instLEUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1875-L1876","name":"instLTUInt32","docLink":"./Init/Prelude.html#instLTUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1872-L1873","name":"instInhabitedUInt32","docLink":"./Init/Prelude.html#instInhabitedUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1870-L1870","name":"instDecidableEqUInt32","docLink":"./Init/Prelude.html#instDecidableEqUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1865-L1868","name":"UInt32.decEq","docLink":"./Init/Prelude.html#UInt32.decEq","doc":"Decides equality on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1857-L1857","name":"UInt32.toNat","docLink":"./Init/Prelude.html#UInt32.toNat","doc":"Unpack a `UInt32` as a `Nat`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1849-L1850","name":"UInt32.ofNatCore","docLink":"./Init/Prelude.html#UInt32.ofNatCore","doc":"Pack a `Nat` less than `2^32` into a `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1836-L1839","name":"UInt32","docLink":"./Init/Prelude.html#UInt32","doc":"The type of unsigned 32-bit integers. This type has special support in the\ncompiler to make it actually 32 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1830-L1830","name":"UInt32.size","docLink":"./Init/Prelude.html#UInt32.size","doc":"The size of type `UInt32`, that is, `2^32 = 4294967296`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1826-L1827","name":"instInhabitedUInt16","docLink":"./Init/Prelude.html#instInhabitedUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1824-L1824","name":"instDecidableEqUInt16","docLink":"./Init/Prelude.html#instDecidableEqUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1819-L1822","name":"UInt16.decEq","docLink":"./Init/Prelude.html#UInt16.decEq","doc":"Decides equality on `UInt16`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1810-L1811","name":"UInt16.ofNatCore","docLink":"./Init/Prelude.html#UInt16.ofNatCore","doc":"Pack a `Nat` less than `2^16` into a `UInt16`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1797-L1800","name":"UInt16","docLink":"./Init/Prelude.html#UInt16","doc":"The type of unsigned 16-bit integers. This type has special support in the\ncompiler to make it actually 16 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1791-L1791","name":"UInt16.size","docLink":"./Init/Prelude.html#UInt16.size","doc":"The size of type `UInt16`, that is, `2^16 = 65536`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1787-L1788","name":"instInhabitedUInt8","docLink":"./Init/Prelude.html#instInhabitedUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1785-L1785","name":"instDecidableEqUInt8","docLink":"./Init/Prelude.html#instDecidableEqUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1780-L1783","name":"UInt8.decEq","docLink":"./Init/Prelude.html#UInt8.decEq","doc":"Decides equality on `UInt8`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1771-L1772","name":"UInt8.ofNatCore","docLink":"./Init/Prelude.html#UInt8.ofNatCore","doc":"Pack a `Nat` less than `2^8` into a `UInt8`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1758-L1761","name":"UInt8","docLink":"./Init/Prelude.html#UInt8","doc":"The type of unsigned 8-bit integers. This type has special support in the\ncompiler to make it actually 8 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1752-L1752","name":"UInt8.size","docLink":"./Init/Prelude.html#UInt8.size","doc":"The size of type `UInt8`, that is, `2^8 = 256`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1749-L1749","name":"Fin.decLe","docLink":"./Init/Prelude.html#Fin.decLe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1748-L1748","name":"Fin.decLt","docLink":"./Init/Prelude.html#Fin.decLt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1745-L1746","name":"instLEFin","docLink":"./Init/Prelude.html#instLEFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1742-L1743","name":"instLTFin","docLink":"./Init/Prelude.html#instLTFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1736-L1740","name":"instDecidableEqFin","docLink":"./Init/Prelude.html#instDecidableEqFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1733-L1734","name":"Fin.ne_of_val_ne","docLink":"./Init/Prelude.html#Fin.ne_of_val_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1730-L1731","name":"Fin.val_eq_of_eq","docLink":"./Init/Prelude.html#Fin.val_eq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1727-L1728","name":"Fin.eq_of_val_eq","docLink":"./Init/Prelude.html#Fin.eq_of_val_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1720-L1725","name":"Fin","docLink":"./Init/Prelude.html#Fin","doc":"`Fin n` is a natural number `i` with the constraint that `0 ≤ i < n`.\nIt is the \"canonical type with `n` elements\".\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1713-L1714","name":"System.Platform.numBits_eq","docLink":"./Init/Prelude.html#System.Platform.numBits_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1710-L1711","name":"System.Platform.numBits","docLink":"./Init/Prelude.html#System.Platform.numBits","doc":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1706-L1707","name":"System.Platform.getNumBits","docLink":"./Init/Prelude.html#System.Platform.getNumBits","doc":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits.\n\nThis function is opaque because we cannot guarantee at compile time that the target\nwill have the same size as the host, and also because we would like to avoid\ntypechecking being architecture-dependent. Nevertheless, lean only works on\n64 and 32 bit systems so we can encode this as a fact available for proof purposes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1695-L1696","name":"instSubNat","docLink":"./Init/Prelude.html#instSubNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1691-L1693","name":"Nat.sub","docLink":"./Init/Prelude.html#Nat.sub","doc":"(Truncated) subtraction of natural numbers. Because natural numbers are not\nclosed under subtraction, we define `m - n` to be `0` when `n < m`.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1678-L1679","name":"Nat.decLt","docLink":"./Init/Prelude.html#Nat.decLt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1674-L1675","name":"Nat.decLe","docLink":"./Init/Prelude.html#Nat.decLe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1670-L1671","name":"Nat.not_le_of_not_ble_eq_true","docLink":"./Init/Prelude.html#Nat.not_le_of_not_ble_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1665-L1668","name":"Nat.ble_eq_true_of_le","docLink":"./Init/Prelude.html#Nat.ble_eq_true_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1661-L1663","name":"Nat.ble_succ_eq_true","docLink":"./Init/Prelude.html#Nat.ble_succ_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1657-L1659","name":"Nat.ble_self_eq_true","docLink":"./Init/Prelude.html#Nat.ble_self_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1652-L1655","name":"Nat.le_of_ble_eq_true","docLink":"./Init/Prelude.html#Nat.le_of_ble_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1647-L1650","name":"Nat.lt_of_le_of_ne","docLink":"./Init/Prelude.html#Nat.lt_of_le_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1642-L1645","name":"Nat.le_antisymm","docLink":"./Init/Prelude.html#Nat.le_antisymm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1639-L1640","name":"Nat.lt_of_le_of_lt","docLink":"./Init/Prelude.html#Nat.lt_of_le_of_lt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1636-L1637","name":"Nat.lt_irrefl","docLink":"./Init/Prelude.html#Nat.lt_irrefl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1632-L1634","name":"Nat.not_succ_le_self","docLink":"./Init/Prelude.html#Nat.not_succ_le_self","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1621-L1630","name":"Nat.lt_or_ge","docLink":"./Init/Prelude.html#Nat.lt_or_ge","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1611-L1619","name":"Nat.eq_or_lt_of_le","docLink":"./Init/Prelude.html#Nat.eq_or_lt_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1608-L1609","name":"Nat.le_of_lt_succ","docLink":"./Init/Prelude.html#Nat.le_of_lt_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1605-L1606","name":"Nat.le_of_succ_le_succ","docLink":"./Init/Prelude.html#Nat.le_of_succ_le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1600-L1603","name":"Nat.pred_le_pred","docLink":"./Init/Prelude.html#Nat.pred_le_pred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1596-L1598","name":"Nat.pred","docLink":"./Init/Prelude.html#Nat.pred","doc":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1585-L1586","name":"Nat.succ_pos","docLink":"./Init/Prelude.html#Nat.succ_pos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1582-L1583","name":"Nat.le_refl","docLink":"./Init/Prelude.html#Nat.le_refl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1579-L1580","name":"Nat.le_succ_of_le","docLink":"./Init/Prelude.html#Nat.le_succ_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1576-L1577","name":"Nat.le_succ","docLink":"./Init/Prelude.html#Nat.le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1573-L1574","name":"Nat.lt_trans","docLink":"./Init/Prelude.html#Nat.lt_trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1569-L1571","name":"Nat.le_trans","docLink":"./Init/Prelude.html#Nat.le_trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1566-L1567","name":"Nat.le_step","docLink":"./Init/Prelude.html#Nat.le_step","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1563-L1564","name":"Nat.zero_lt_succ","docLink":"./Init/Prelude.html#Nat.zero_lt_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1559-L1561","name":"Nat.succ_le_succ","docLink":"./Init/Prelude.html#Nat.succ_le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1555-L1557","name":"Nat.zero_le","docLink":"./Init/Prelude.html#Nat.zero_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1552-L1553","name":"Nat.not_lt_zero","docLink":"./Init/Prelude.html#Nat.not_lt_zero","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1548-L1550","name":"Nat.not_succ_le_zero","docLink":"./Init/Prelude.html#Nat.not_succ_le_zero","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1545-L1546","name":"instLTNat","docLink":"./Init/Prelude.html#instLTNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1542-L1543","name":"Nat.lt","docLink":"./Init/Prelude.html#Nat.lt","doc":"The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1538-L1539","name":"instLENat","docLink":"./Init/Prelude.html#instLENat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1532-L1536","name":"Nat.le","docLink":"./Init/Prelude.html#Nat.le","doc":"An inductive definition of the less-equal relation on natural numbers,\ncharacterized as the least relation `≤` such that `n ≤ n` and `n ≤ m → n ≤ m + 1`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1522-L1526","name":"Nat.ble","docLink":"./Init/Prelude.html#Nat.ble","doc":"The (Boolean) less-equal relation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1511-L1511","name":"instDecidableEqNat","docLink":"./Init/Prelude.html#instDecidableEqNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1506-L1509","name":"Nat.decEq","docLink":"./Init/Prelude.html#Nat.decEq","doc":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1490-L1496","name":"Nat.ne_of_beq_eq_false","docLink":"./Init/Prelude.html#Nat.ne_of_beq_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1481-L1488","name":"Nat.eq_of_beq_eq_true","docLink":"./Init/Prelude.html#Nat.eq_of_beq_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1478-L1479","name":"instBEqNat","docLink":"./Init/Prelude.html#instBEqNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1472-L1476","name":"Nat.beq","docLink":"./Init/Prelude.html#Nat.beq","doc":"(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1460-L1461","name":"instPowNat","docLink":"./Init/Prelude.html#instPowNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1456-L1458","name":"Nat.pow","docLink":"./Init/Prelude.html#Nat.pow","doc":"The power operation on natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1444-L1445","name":"instMulNat","docLink":"./Init/Prelude.html#instMulNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1440-L1442","name":"Nat.mul","docLink":"./Init/Prelude.html#Nat.mul","doc":"Multiplication of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1424-L1425","name":"instAddNat","docLink":"./Init/Prelude.html#instAddNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1420-L1422","name":"Nat.add","docLink":"./Init/Prelude.html#Nat.add","doc":"Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1407-L1409","name":"Membership","docLink":"./Init/Prelude.html#Membership","doc":"The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1394-L1395","name":"instHShiftRight","docLink":"./Init/Prelude.html#instHShiftRight","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1390-L1391","name":"instHShiftLeft","docLink":"./Init/Prelude.html#instHShiftLeft","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1386-L1387","name":"instHOr","docLink":"./Init/Prelude.html#instHOr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1382-L1383","name":"instHXor","docLink":"./Init/Prelude.html#instHXor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1378-L1379","name":"instHAnd","docLink":"./Init/Prelude.html#instHAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1374-L1375","name":"instHAndThen","docLink":"./Init/Prelude.html#instHAndThen","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1370-L1371","name":"instHOrElse","docLink":"./Init/Prelude.html#instHOrElse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1366-L1367","name":"instHAppend","docLink":"./Init/Prelude.html#instHAppend","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1362-L1363","name":"instHPow","docLink":"./Init/Prelude.html#instHPow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1358-L1359","name":"instHMod","docLink":"./Init/Prelude.html#instHMod","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1354-L1355","name":"instHDiv","docLink":"./Init/Prelude.html#instHDiv","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1350-L1351","name":"instHMul","docLink":"./Init/Prelude.html#instHMul","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1346-L1347","name":"instHSub","docLink":"./Init/Prelude.html#instHSub","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1342-L1343","name":"instHAdd","docLink":"./Init/Prelude.html#instHAdd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1337-L1339","name":"ShiftRight","docLink":"./Init/Prelude.html#ShiftRight","doc":"The homogeneous version of `HShiftRight`: `a >>> b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1332-L1334","name":"ShiftLeft","docLink":"./Init/Prelude.html#ShiftLeft","doc":"The homogeneous version of `HShiftLeft`: `a <<< b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1327-L1329","name":"Complement","docLink":"./Init/Prelude.html#Complement","doc":"The typeclass behind the notation `~~~a : α` where `a : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1322-L1324","name":"OrOp","docLink":"./Init/Prelude.html#OrOp","doc":"The homogeneous version of `HOr`: `a ||| b : α` where `a b : α`.\n(It is called `OrOp` because `Or` is taken for the propositional connective.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1314-L1316","name":"Xor","docLink":"./Init/Prelude.html#Xor","doc":"The homogeneous version of `HXor`: `a ^^^ b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1309-L1311","name":"AndOp","docLink":"./Init/Prelude.html#AndOp","doc":"The homogeneous version of `HAnd`: `a &&& b : α` where `a b : α`.\n(It is called `AndOp` because `And` is taken for the propositional connective.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1301-L1303","name":"AndThen","docLink":"./Init/Prelude.html#AndThen","doc":"The homogeneous version of `HAndThen`: `a >> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1292-L1294","name":"OrElse","docLink":"./Init/Prelude.html#OrElse","doc":"The homogeneous version of `HOrElse`: `a <|> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1283-L1285","name":"Append","docLink":"./Init/Prelude.html#Append","doc":"The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1278-L1280","name":"Pow","docLink":"./Init/Prelude.html#Pow","doc":"The homogeneous version of `HPow`: `a ^ b : α` where `a : α`, `b : β`.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1269-L1271","name":"Mod","docLink":"./Init/Prelude.html#Mod","doc":"The homogeneous version of `HMod`: `a % b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1264-L1266","name":"Div","docLink":"./Init/Prelude.html#Div","doc":"The homogeneous version of `HDiv`: `a / b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1258-L1261","name":"Neg","docLink":"./Init/Prelude.html#Neg","doc":"The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1250-L1252","name":"Mul","docLink":"./Init/Prelude.html#Mul","doc":"The homogeneous version of `HMul`: `a * b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1245-L1247","name":"Sub","docLink":"./Init/Prelude.html#Sub","doc":"The homogeneous version of `HSub`: `a - b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1240-L1242","name":"Add","docLink":"./Init/Prelude.html#Add","doc":"The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1232-L1237","name":"HShiftRight","docLink":"./Init/Prelude.html#HShiftRight","doc":"The typeclass behind the notation `a >>> b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1223-L1229","name":"HShiftLeft","docLink":"./Init/Prelude.html#HShiftLeft","doc":"The typeclass behind the notation `a <<< b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1217-L1220","name":"HOr","docLink":"./Init/Prelude.html#HOr","doc":"The typeclass behind the notation `a ||| b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1211-L1214","name":"HXor","docLink":"./Init/Prelude.html#HXor","doc":"The typeclass behind the notation `a ^^^ b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1205-L1208","name":"HAnd","docLink":"./Init/Prelude.html#HAnd","doc":"The typeclass behind the notation `a &&& b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1197-L1202","name":"HAndThen","docLink":"./Init/Prelude.html#HAndThen","doc":"The typeclass behind the notation `a >> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1185-L1190","name":"HOrElse","docLink":"./Init/Prelude.html#HOrElse","doc":"The typeclass behind the notation `a <|> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1175-L1178","name":"HAppend","docLink":"./Init/Prelude.html#HAppend","doc":"The notation typeclass for heterogeneous append.\nThis enables the notation `a ++ b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1166-L1169","name":"HPow","docLink":"./Init/Prelude.html#HPow","doc":"The notation typeclass for heterogeneous exponentiation.\nThis enables the notation `a ^ b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1156-L1160","name":"HMod","docLink":"./Init/Prelude.html#HMod","doc":"The notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation `a % b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1143-L1150","name":"HDiv","docLink":"./Init/Prelude.html#HDiv","doc":"The notation typeclass for heterogeneous division.\nThis enables the notation `a / b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1134-L1137","name":"HMul","docLink":"./Init/Prelude.html#HMul","doc":"The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1124-L1128","name":"HSub","docLink":"./Init/Prelude.html#HSub","doc":"The notation typeclass for heterogeneous subtraction.\nThis enables the notation `a - b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1115-L1118","name":"HAdd","docLink":"./Init/Prelude.html#HAdd","doc":"The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1108-L1109","name":"instTransEq_1","docLink":"./Init/Prelude.html#instTransEq_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1105-L1106","name":"instTransEq","docLink":"./Init/Prelude.html#instTransEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1099-L1101","name":"Trans","docLink":"./Init/Prelude.html#Trans","doc":"Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (·≤·) (·<·) (·<·)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1087-L1088","name":"minOfLe","docLink":"./Init/Prelude.html#minOfLe","doc":"Implementation of the `min` operation using `≤`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1078-L1080","name":"Min","docLink":"./Init/Prelude.html#Min","doc":"`Min α` is the typeclass which supports the operation `min x y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1074-L1075","name":"maxOfLe","docLink":"./Init/Prelude.html#maxOfLe","doc":"Implementation of the `max` operation using `≤`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1065-L1067","name":"Max","docLink":"./Init/Prelude.html#Max","doc":"`Max α` is the typeclass which supports the operation `max x y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1062-L1062","name":"GT.gt","docLink":"./Init/Prelude.html#GT.gt","doc":"`a > b` is an abbreviation for `b < a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1060-L1060","name":"GE.ge","docLink":"./Init/Prelude.html#GE.ge","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1055-L1057","name":"LT","docLink":"./Init/Prelude.html#LT","doc":"`LT α` is the typeclass which supports the notation `x < y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1050-L1052","name":"LE","docLink":"./Init/Prelude.html#LE","doc":"`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1046-L1047","name":"instOfNatNat","docLink":"./Init/Prelude.html#instOfNatNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1038-L1043","name":"OfNat","docLink":"./Init/Prelude.html#OfNat","doc":"The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1023-L1024","name":"instInhabitedNat","docLink":"./Init/Prelude.html#instInhabitedNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L1015-L1021","name":"Nat","docLink":"./Init/Prelude.html#Nat","doc":"The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L979-L981","name":"not","docLink":"./Init/Prelude.html#not","doc":"`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L970-L973","name":"and","docLink":"./Init/Prelude.html#and","doc":"`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L959-L962","name":"or","docLink":"./Init/Prelude.html#or","doc":"`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L948-L951","name":"cond","docLink":"./Init/Prelude.html#cond","doc":"`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L935-L938","name":"instDecidableNot","docLink":"./Init/Prelude.html#instDecidableNot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L924-L933","name":"instDecidableOr","docLink":"./Init/Prelude.html#instDecidableOr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L915-L922","name":"instDecidableAnd","docLink":"./Init/Prelude.html#instDecidableAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L912-L913","name":"ite","docLink":"./Init/Prelude.html#ite","doc":"`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L890-L891","name":"dite","docLink":"./Init/Prelude.html#dite","doc":"\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr ⟨i, h⟩` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get ⟨i, h⟩ else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L872-L873","name":"instBEq","docLink":"./Init/Prelude.html#instBEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L866-L868","name":"BEq","docLink":"./Init/Prelude.html#BEq","doc":"`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L855-L856","name":"instDecidableEqBool","docLink":"./Init/Prelude.html#instDecidableEqBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L848-L853","name":"Bool.decEq","docLink":"./Init/Prelude.html#Bool.decEq","doc":"Decidable equality for Bool "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L842-L845","name":"of_decide_eq_self_eq_true","docLink":"./Init/Prelude.html#of_decide_eq_self_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L837-L840","name":"of_decide_eq_false","docLink":"./Init/Prelude.html#of_decide_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L832-L835","name":"of_decide_eq_true","docLink":"./Init/Prelude.html#of_decide_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L828-L830","name":"decide_eq_false","docLink":"./Init/Prelude.html#decide_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L824-L826","name":"decide_eq_true","docLink":"./Init/Prelude.html#decide_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L820-L821","name":"decEq","docLink":"./Init/Prelude.html#decEq","doc":"Proves that `a = b` is decidable given `DecidableEq α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L816-L817","name":"DecidableEq","docLink":"./Init/Prelude.html#DecidableEq","doc":"Asserts that `α` has decidable equality, that is, `a = b` is decidable\nfor all `a b : α`. See `Decidable`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L809-L810","name":"DecidableRel","docLink":"./Init/Prelude.html#DecidableRel","doc":"A decidable relation. See `Decidable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L805-L806","name":"DecidablePred","docLink":"./Init/Prelude.html#DecidablePred","doc":"A decidable predicate. See `Decidable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L799-L800","name":"Decidable.decide","docLink":"./Init/Prelude.html#Decidable.decide","doc":"Convert a decidable proposition into a boolean value.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the boolean value\nwhich is `true` if `p` is true and `false` if `p` is false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L787-L791","name":"Decidable","docLink":"./Init/Prelude.html#Decidable","doc":"`Decidable p` is a data-carrying class that supplies a proof that `p` is\neither `true` or `false`. It is equivalent to `Bool` (and in fact it has the\nsame code generation as `Bool`) together with a proof that the `Bool` is\ntrue iff `p` is.\n\n`Decidable` instances are used to infer \"computation strategies\" for\npropositions, so that you can have the convenience of writing propositions\ninside `if` statements and executing them (which actually executes the inferred\ndecidability instance instead of the proposition, which has no code).\n\nIf a proposition `p` is `Decidable`, then `(by decide : p)` will prove it by\nevaluating the decidability instance to `isTrue h` and returning `h`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L771-L771","name":"ULift.down_up","docLink":"./Init/Prelude.html#ULift.down_up","doc":"Bijection between `α` and `ULift.{v} α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L768-L768","name":"ULift.up_down","docLink":"./Init/Prelude.html#ULift.up_down","doc":"Bijection between `α` and `ULift.{v} α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L763-L765","name":"ULift","docLink":"./Init/Prelude.html#ULift","doc":"Universe lifting operation from a lower `Type` universe to a higher one.\nTo express this using level variables, the input is `Type s` and the output is\n`Type (max s r)`, so if `s ≤ r` then the latter is (definitionally) `Type r`.\n\nThe universe variable `r` is written first so that `ULift.{r} α` can be used\nwhen `s` can be inferred from the type of `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L752-L753","name":"instInhabitedNonemptyType","docLink":"./Init/Prelude.html#instInhabitedNonemptyType","doc":"`NonemptyType` is inhabited, because `PUnit` is a nonempty type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L748-L749","name":"NonemptyType.type","docLink":"./Init/Prelude.html#NonemptyType.type","doc":"The underlying type of a `NonemptyType`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L745-L745","name":"NonemptyType","docLink":"./Init/Prelude.html#NonemptyType","doc":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L737-L737","name":"PLift.down_up","docLink":"./Init/Prelude.html#PLift.down_up","doc":"Bijection between `α` and `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L734-L734","name":"PLift.up_down","docLink":"./Init/Prelude.html#PLift.up_down","doc":"Bijection between `α` and `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L729-L731","name":"PLift","docLink":"./Init/Prelude.html#PLift","doc":"Universe lifting operation from `Sort u` to `Type u`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L726-L726","name":"instInhabitedBool","docLink":"./Init/Prelude.html#instInhabitedBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L723-L724","name":"instInhabitedForAll_1","docLink":"./Init/Prelude.html#instInhabitedForAll_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L720-L721","name":"instInhabitedForAll","docLink":"./Init/Prelude.html#instInhabitedForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L717-L718","name":"instInhabitedSort","docLink":"./Init/Prelude.html#instInhabitedSort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L714-L715","name":"instNonemptyForAll_1","docLink":"./Init/Prelude.html#instNonemptyForAll_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L711-L712","name":"instNonemptyForAll","docLink":"./Init/Prelude.html#instNonemptyForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L708-L709","name":"Classical.ofNonempty","docLink":"./Init/Prelude.html#Classical.ofNonempty","doc":"A variation on `Classical.choice` that uses typeclass inference to\ninfer the proof of `Nonempty α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L701-L702","name":"instNonempty","docLink":"./Init/Prelude.html#instNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L697-L699","name":"Nonempty.elim","docLink":"./Init/Prelude.html#Nonempty.elim","doc":"The elimination principle for `Nonempty α`. If `Nonempty α`, and we can\nprove `p` given any element `x : α`, then `p` holds. Note that it is essential\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\nto `Classical.choice`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L689-L689","name":"Classical.choice","docLink":"./Init/Prelude.html#Classical.choice","doc":"**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i => Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L663-L665","name":"Nonempty","docLink":"./Init/Prelude.html#Nonempty","doc":"`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L647-L651","name":"Inhabited","docLink":"./Init/Prelude.html#Inhabited","doc":"`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L632-L634","name":"ne_true_of_eq_false","docLink":"./Init/Prelude.html#ne_true_of_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L628-L630","name":"ne_false_of_eq_true","docLink":"./Init/Prelude.html#ne_false_of_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L624-L626","name":"eq_true_of_ne_false","docLink":"./Init/Prelude.html#eq_true_of_ne_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L620-L622","name":"eq_false_of_ne_true","docLink":"./Init/Prelude.html#eq_false_of_ne_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L618-L618","name":"sorryAx","docLink":"./Init/Prelude.html#sorryAx","doc":"Auxiliary axiom used to implement `sorry`.\n\nThe `sorry` term/tactic expands to `sorryAx _ (synthetic := false)`. This is a\nproof of anything, which is intended for stubbing out incomplete parts of a\nproof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n\nThe `synthetic` flag is false when written explicitly by the user, but it is\nset to `true` when a tactic fails to prove a goal, or if there is a type error\nin the expression. A synthetic `sorry` acts like a regular one, except that it\nsuppresses follow-up errors in order to prevent one error from causing a cascade\nof other errors because the desired term was not constructed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L599-L599","name":"namedPattern","docLink":"./Init/Prelude.html#namedPattern","doc":"Auxiliary declaration used to implement named patterns like `x@h:p`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L595-L595","name":"outParam","docLink":"./Init/Prelude.html#outParam","doc":"Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L577-L577","name":"optParam","docLink":"./Init/Prelude.html#optParam","doc":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L560-L567","name":"Subtype","docLink":"./Init/Prelude.html#Subtype","doc":"`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L545-L549","name":"Bool","docLink":"./Init/Prelude.html#Bool","doc":"`Bool` is the type of boolean values, `true` and `false`. Classically,\nthis is equivalent to `Prop` (the type of propositions), but the distinction\nis important for programming, because values of type `Prop` are erased in the\ncode generator, while `Bool` corresponds to the type called `bool` or `boolean`\nin most programming languages.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L533-L536","name":"Or.elim","docLink":"./Init/Prelude.html#Or.elim","doc":"Proof by cases on an `Or`. If `a ∨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L526-L527","name":"Or.intro_right","docLink":"./Init/Prelude.html#Or.intro_right","doc":"Alias for `Or.inr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L522-L523","name":"Or.intro_left","docLink":"./Init/Prelude.html#Or.intro_left","doc":"Alias for `Or.inl`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L515-L519","name":"Or","docLink":"./Init/Prelude.html#Or","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L499-L507","name":"And","docLink":"./Init/Prelude.html#And","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L488-L492","name":"MProd","docLink":"./Init/Prelude.html#MProd","doc":"Similar to `Prod`, but `α` and `β` are in the same universe.\nWe say `MProd` is the universe monomorphic product type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L478-L482","name":"PProd","docLink":"./Init/Prelude.html#PProd","doc":"Similar to `Prod`, but `α` and `β` can be propositions.\nWe use this Type internally to automatically generate the `brecOn` recursor.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L466-L470","name":"Prod","docLink":"./Init/Prelude.html#Prod","doc":"Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L451-L455","name":"eq_of_heq","docLink":"./Init/Prelude.html#eq_of_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L448-L449","name":"HEq.rfl","docLink":"./Init/Prelude.html#HEq.rfl","doc":"A version of `HEq.refl` with an implicit argument. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L443-L445","name":"HEq","docLink":"./Init/Prelude.html#HEq","doc":"Heterogeneous equality. `HEq a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `congr`: If `HEq f g` and `HEq x y`\nand `f x` and `g y` are well typed it does not follow that `HEq (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `HEq a b` ae equivalent.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L429-L429","name":"Quot.lcInv","docLink":"./Init/Prelude.html#Quot.lcInv","doc":"Unsafe auxiliary constant used by the compiler to erase `Quot.lift`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L363-L364","name":"congrFun","docLink":"./Init/Prelude.html#congrFun","doc":"Congruence in the function part of an application: If `f = g` then `f a = g a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L359-L360","name":"congr","docLink":"./Init/Prelude.html#congr","doc":"Congruence in both function and argument. If `f₁ = f₂` and `a₁ = a₂` then\n`f₁ a₁ = f₂ a₂`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L349-L350","name":"congrArg","docLink":"./Init/Prelude.html#congrArg","doc":"Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing a₁> = <something containing a₂>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L336-L337","name":"cast","docLink":"./Init/Prelude.html#cast","doc":"Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L322-L323","name":"Eq.trans","docLink":"./Init/Prelude.html#Eq.trans","doc":"Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L310-L311","name":"Eq.symm","docLink":"./Init/Prelude.html#Eq.symm","doc":"Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L299-L300","name":"Eq.subst","docLink":"./Init/Prelude.html#Eq.subst","doc":"The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L284-L284","name":"id_eq","docLink":"./Init/Prelude.html#id_eq","doc":"`id x = x`, as a `@[simp]` lemma. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L281-L281","name":"rfl","docLink":"./Init/Prelude.html#rfl","doc":"`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L263-L266","name":"Eq","docLink":"./Init/Prelude.html#Eq","doc":"The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L233-L234","name":"absurd","docLink":"./Init/Prelude.html#absurd","doc":"Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L223-L224","name":"False.elim","docLink":"./Init/Prelude.html#False.elim","doc":"`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L211-L211","name":"Not","docLink":"./Init/Prelude.html#Not","doc":"`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L202-L202","name":"PEmpty","docLink":"./Init/Prelude.html#PEmpty","doc":"The universe-polymorphic empty type. Prefer `Empty` or `False` where\npossible.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L195-L195","name":"Empty","docLink":"./Init/Prelude.html#Empty","doc":"The empty type. It has no constructors. The `Empty.rec`\neliminator expresses the fact that anything follows from the empty type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L189-L189","name":"False","docLink":"./Init/Prelude.html#False","doc":"`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L176-L179","name":"True","docLink":"./Init/Prelude.html#True","doc":"`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L169-L169","name":"lcUnreachable","docLink":"./Init/Prelude.html#lcUnreachable","doc":"Auxiliary unsafe constant used by the Compiler to mark unreachable code.\n\nLike `lcProof`, this is an `unsafe axiom`, which means that even though it is\nnot sound, the kernel will not let us use it for regular proofs.\n\nExecuting this expression to actually synthesize a value of type `α` causes\n**immediate undefined behavior**, and the compiler does take advantage of this\nto optimize the code assuming that it is not called. If it is not optimized out,\nit is likely to appear as a print message saying \"unreachable code\", but this\nbehavior is not guaranteed or stable in any way.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L154-L154","name":"lcCast","docLink":"./Init/Prelude.html#lcCast","doc":"Auxiliary unsafe constant used by the Compiler when erasing casts.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L149-L149","name":"lcProof","docLink":"./Init/Prelude.html#lcProof","doc":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L138-L138","name":"lcErased","docLink":"./Init/Prelude.html#lcErased","doc":"Marker for information that has been erased by the code generator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L135-L135","name":"Unit.unit","docLink":"./Init/Prelude.html#Unit.unit","doc":"`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L129-L129","name":"Unit","docLink":"./Init/Prelude.html#Unit","doc":"The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L109-L111","name":"PUnit","docLink":"./Init/Prelude.html#PUnit","doc":"The unit type, the canonical type with one element, named `unit` or `()`.\nThis is the universe-polymorphic version of `Unit`; it is preferred to use\n`Unit` instead where applicable.\nFor more information about universe levels: [Types as objects](https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L100-L100","name":"inferInstanceAs","docLink":"./Init/Prelude.html#inferInstanceAs","doc":"`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L86-L86","name":"inferInstance","docLink":"./Init/Prelude.html#inferInstance","doc":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L66-L67","name":"Function.const","docLink":"./Init/Prelude.html#Function.const","doc":"The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L52-L53","name":"Function.comp","docLink":"./Init/Prelude.html#Function.comp","doc":"Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Prelude.lean#L33-L33","name":"id","docLink":"./Init/Prelude.html#id","doc":"The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n"}]}