{"name":"Lean.Compiler.LCNF.Types","instances":[],"imports":["Init","Lean.Meta.InferType"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L286-L289","name":"Lean.Compiler.LCNF.isInductiveWithNoCtors","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isInductiveWithNoCtors","doc":"Return `true` if `type` is an inductive datatype with 0 constructors. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L280-L283","name":"Lean.Compiler.LCNF.getArrowArity","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.getArrowArity","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L275-L278","name":"Lean.Compiler.LCNF.isArrowClass?","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isArrowClass?","doc":"`isArrowClass? type` return `some ClsName` if the LCNF `type` is an instance of the class `ClsName`, or\nif it is arrow producing an instance of the class `ClsName`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L264-L269","name":"Lean.Compiler.LCNF.isClass?","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isClass?","doc":"`isClass? type` return `some ClsName` if the LCNF `type` is an instance of the class `ClsName`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L255-L259","name":"Lean.Compiler.LCNF.maybeTypeFormerType","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.maybeTypeFormerType","doc":"Return `true` if `type` is a LCNF type former type or it is an \"any\" type.\nThis function is similar to `isTypeFormerType`, but more liberal.\nFor example, `isTypeFormerType` returns false for `◾` and `Nat → ◾`, but\nthis function returns true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L243-L247","name":"Lean.Compiler.LCNF.isPredicateType","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isPredicateType","doc":"Return `true` if `type` is a predicate.\nExamples: `Nat → Prop`, `Prop`, `Int → Bool → Prop`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L229-L236","name":"Lean.Compiler.LCNF.instantiateForall.go","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.instantiateForall.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L226-L237","name":"Lean.Compiler.LCNF.instantiateForall","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.instantiateForall","doc":"Given a LCNF `type` of the form `forall (a_1 : A_1) ... (a_n : A_n), B[a_1, ..., a_n]` and `p_1 : A_1, ... p_n : A_n`,\nreturn `B[p_1, ..., p_n]`.\n\nRemark: similar to `Meta.instantiateForall`, buf for LCNF types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L214-L218","name":"Lean.Compiler.LCNF.isTypeFormerType","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isTypeFormerType","doc":"Return `true` if `type` is a LCNF type former type.\n\nRemark: This is faster than `Lean.Meta.isTypeFormer`, as this\nassumes that the input `type` is an LCNF type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L178-L204","name":"Lean.Compiler.LCNF.joinTypes?","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.joinTypes?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L175-L176","name":"Lean.Compiler.LCNF.joinTypes","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.joinTypes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L154-L171","name":"Lean.Compiler.LCNF.toLCNFType.visitApp","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.toLCNFType.visitApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L143-L152","name":"Lean.Compiler.LCNF.toLCNFType.visitForall","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.toLCNFType.visitForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L135-L141","name":"Lean.Compiler.LCNF.toLCNFType.whnfEta","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.toLCNFType.whnfEta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L115-L171","name":"Lean.Compiler.LCNF.toLCNFType","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.toLCNFType","doc":"Convert a Lean type into a LCNF type used by the code generator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L46-L47","name":"Lean.Compiler.LCNF.isPropFormer","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isPropFormer","doc":"Return true iff `e : Prop` or `e : As → Prop`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L32-L41","name":"Lean.Compiler.LCNF.isPropFormerType.go","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isPropFormerType.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L27-L41","name":"Lean.Compiler.LCNF.isPropFormerType","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isPropFormerType","doc":"Return true iff `type` is `Prop` or `As → Prop`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L19-L22","name":"Lean.Compiler.LCNF.isPropFormerTypeQuick","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.isPropFormerTypeQuick","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L16-L17","name":"Lean.Expr.isErased","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Expr.isErased","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L14-L14","name":"Lean.Compiler.LCNF.erasedExpr","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.LCNF.erasedExpr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Lean/Compiler/LCNF/Types.lean#L10-L10","name":"Lean.Compiler.«term◾»","docLink":"./Lean/Compiler/LCNF/Types.html#Lean.Compiler.«term◾»","doc":""}]}