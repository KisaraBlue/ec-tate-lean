{"name":"Init.Data.Array.BasicAux","instances":[],"imports":["Init.Data.Array.Basic","Init.Data.Nat.Linear","Init.NotationExtra"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L73-L74","name":"Array.mapMono","docLink":"./Init/Data/Array/BasicAux.html#Array.mapMono","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L70-L71","name":"Array.mapMonoM","docLink":"./Init/Data/Array/BasicAux.html#Array.mapMonoM","doc":"Monomorphic `Array.mapM`. The internal implementation uses pointer equality, and does not allocate a new array\nif the result of each `f a` is a pointer equal value `a`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L43-L49","name":"Array.mapM'.go","docLink":"./Init/Data/Array/BasicAux.html#Array.mapM'.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L40-L50","name":"Array.mapM'","docLink":"./Init/Data/Array/BasicAux.html#Array.mapM'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L35-L38","name":"List.toArray_eq_toArray_eq","docLink":"./Init/Data/Array/BasicAux.html#List.toArray_eq_toArray_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Data/Array/BasicAux.lean#L11-L15","name":"Array.of_push_eq_push","docLink":"./Init/Data/Array/BasicAux.html#Array.of_push_eq_push","doc":""}]}