{"name":"Init.Coe","instances":[{"typeNames":[],"name":"coeTrans","className":"CoeTC"},{"typeNames":[],"name":"coeBase","className":"CoeTC"},{"typeNames":[],"name":"coeOfHeafOfTCOfTail","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfHeadOfTC","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfTCOfTail","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfHeadOfTail","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfHead","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfTail","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfTC","className":"CoeHTCT"},{"typeNames":[],"name":"coeOfHTCT","className":"CoeT"},{"typeNames":[],"name":"coeOfDep","className":"CoeT"},{"typeNames":[],"name":"coeId","className":"CoeT"},{"typeNames":[],"name":"coeSortToCoeTail","className":"CoeTail"},{"typeNames":["Bool"],"name":"boolToProp","className":"Coe"},{"typeNames":["Bool"],"name":"boolToSort","className":"CoeSort"},{"typeNames":["Bool"],"name":"decPropToBool","className":"CoeDep"},{"typeNames":["Option"],"name":"optionCoe","className":"CoeTail"},{"typeNames":["Subtype"],"name":"subtypeCoe","className":"CoeHead"},{"typeNames":[],"name":"instCoeDep","className":"CoeDep"},{"typeNames":[],"name":"instCoeTail","className":"CoeTail"},{"typeNames":[],"name":"instCoeTail_1","className":"CoeTail"}],"imports":["Init.Prelude"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L292-L293","name":"instCoeTail_1","docLink":"./Init/Coe.html#instCoeTail_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L289-L290","name":"instCoeTail","docLink":"./Init/Coe.html#instCoeTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L286-L287","name":"instCoeDep","docLink":"./Init/Coe.html#instCoeDep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L281-L284","name":"Lean.Internal.coeM","docLink":"./Init/Coe.html#Lean.Internal.coeM","doc":"Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercing the result type under a monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L271-L274","name":"Lean.Internal.liftCoeM","docLink":"./Init/Coe.html#Lean.Internal.liftCoeM","doc":"Helper definition used by the elaborator. It is not meant to be used directly by users.\n\nThis is used for coercions between monads, in the case where we want to apply\na monad lift and a coercion on the result type at the same time.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L260-L261","name":"subtypeCoe","docLink":"./Init/Coe.html#subtypeCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L257-L258","name":"optionCoe","docLink":"./Init/Coe.html#optionCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L254-L255","name":"decPropToBool","docLink":"./Init/Coe.html#decPropToBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L251-L252","name":"boolToSort","docLink":"./Init/Coe.html#boolToSort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L248-L249","name":"boolToProp","docLink":"./Init/Coe.html#boolToProp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L243-L244","name":"coeSortToCoeTail","docLink":"./Init/Coe.html#coeSortToCoeTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L240-L241","name":"coeId","docLink":"./Init/Coe.html#coeId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L237-L238","name":"coeOfDep","docLink":"./Init/Coe.html#coeOfDep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L234-L235","name":"coeOfHTCT","docLink":"./Init/Coe.html#coeOfHTCT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L231-L232","name":"coeOfTC","docLink":"./Init/Coe.html#coeOfTC","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L228-L229","name":"coeOfTail","docLink":"./Init/Coe.html#coeOfTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L225-L226","name":"coeOfHead","docLink":"./Init/Coe.html#coeOfHead","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L222-L223","name":"coeOfHeadOfTail","docLink":"./Init/Coe.html#coeOfHeadOfTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L219-L220","name":"coeOfTCOfTail","docLink":"./Init/Coe.html#coeOfTCOfTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L216-L217","name":"coeOfHeadOfTC","docLink":"./Init/Coe.html#coeOfHeadOfTC","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L213-L214","name":"coeOfHeafOfTCOfTail","docLink":"./Init/Coe.html#coeOfHeafOfTCOfTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L210-L211","name":"coeBase","docLink":"./Init/Coe.html#coeBase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L207-L208","name":"coeTrans","docLink":"./Init/Coe.html#coeTrans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L198-L205","name":"coeNotation","docLink":"./Init/Coe.html#coeNotation","doc":"`↑x` represents a coercion, which converts `x` of type `α` to type `β`, using\ntypeclasses to resolve a suitable conversion function. You can often leave the\n`↑` off entirely, since coercion is triggered implicitly whenever there is a\ntype error, but in ambiguous cases it can be useful to use `↑` to disambiguate\nbetween e.g. `↑x + ↑y` and `↑(x + y)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L194-L196","name":"CoeSort","docLink":"./Init/Coe.html#CoeSort","doc":"`CoeSort α β` is a coercion to a sort. `β` must be a universe, and if\n`a : α` appears in a place where a type is expected, like `(x : a)` or `a → a`,\nthen it will be turned into `(x : CoeSort.coe a)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L183-L187","name":"CoeFun","docLink":"./Init/Coe.html#CoeFun","doc":"`CoeFun α (γ : α → Sort v)` is a coercion to a function. `γ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : α` appears in an application like `f x` which would not make sense since\n`f` does not have a function type. This is automatically turned into `CoeFun.coe f x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L170-L174","name":"CoeT","docLink":"./Init/Coe.html#CoeT","doc":"`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the \"grammar\" `(CoeHead)? (Coe)* (CoeTail)? | CoeDep`,\nexcept that the empty sequence is not allowed (identity coercions don't need\nthe coercion system at all).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L155-L159","name":"CoeDep","docLink":"./Init/Coe.html#CoeDep","doc":"`CoeDep α (x : α) β` is a typeclass for dependent coercions, that is, the type `β`\ncan depend on `x` (or rather, the value of `x` is available to typeclass search\nso an instance that relates `β` to `x` is allowed).\n\nDependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L142-L145","name":"CoeHTCT","docLink":"./Init/Coe.html#CoeHTCT","doc":"Auxiliary class that contains `CoeHead` + `CoeTC` + `CoeTail`.\n\nA `CoeHTCT` chain has the \"grammar\" `(CoeHead)? (Coe)* (CoeTail)?`, except that\nthe empty sequence is not allowed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L131-L134","name":"CoeTail","docLink":"./Init/Coe.html#CoeTail","doc":"`CoeTail α β` is for coercions that can only appear at the end of a\nsequence of coercions. That is, `α` can be further coerced via `Coe σ α` and\n`CoeHead τ σ` instances but `β` will only be the expected type of the expression.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L121-L124","name":"CoeHead","docLink":"./Init/Coe.html#CoeHead","doc":"`CoeHead α β` is for coercions that can only appear at the beginning of a\nsequence of coercions. That is, `β` can be further coerced via `Coe β γ` and\n`CoeTail γ δ` instances but `α` will only be the inferred type of the input.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L111-L114","name":"CoeTC","docLink":"./Init/Coe.html#CoeTC","doc":"Auxiliary class that contains the transitive closure of `Coe`.\nUsers should generally not implement this directly.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Init/Coe.lean#L102-L105","name":"Coe","docLink":"./Init/Coe.html#Coe","doc":"`Coe α β` is the typeclass for coercions from `α` to `β`. It can be transitively\nchained with other `Coe` instances, and coercion is automatically used when\n`x` has type `α` but it is used in a context where `β` is expected.\nYou can use the `↑x` operator to explicitly trigger coercion.\n"}]}