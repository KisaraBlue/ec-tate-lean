{"name":"Init.Notation","instances":[{"typeNames":["Lean.TSyntax","Lean.Syntax"],"name":"Lean.instCoeHeadTSyntaxSyntax","className":"CoeHead"},{"typeNames":["Lean.SyntaxNodeKind","Lean.SyntaxNodeKinds"],"name":"Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","className":"Coe"},{"typeNames":["Lean.Syntax","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr1","List.nil"],"name":"Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"}],"imports":["Init.Prelude","Init.Coe"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L504-L509","name":"Lean.includeStr","docLink":"./Init/Notation.html#Lean.includeStr","doc":"When `parent_dir` contains the current Lean file, `include_str \"path\" / \"to\" / \"file\"` becomes\na string literal with the contents of the file at `\"parent_dir\" / \"path\" / \"to\" / \"file\"`. If this\nfile cannot be read, elaboration fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L495-L502","name":"Lean.deprecated","docLink":"./Init/Notation.html#Lean.deprecated","doc":"The attribute `@[deprecated]` on a declaration indicates that the declaration\nis discouraged for use in new code, and/or should be migrated away from in\nexisting code. It may be removed in a future version of the library.\n\n`@[deprecated myBetterDef]` means that `myBetterDef` is the suggested replacement.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L492-L493","name":"Lean.withAnnotateTerm","docLink":"./Init/Notation.html#Lean.withAnnotateTerm","doc":"`with_annotate_term stx e` annotates the lexical range of `stx : Syntax` with term info for `e`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L489-L490","name":"Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","docLink":"./Init/Notation.html#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L483-L487","name":"Lean.rawStx.quot","docLink":"./Init/Notation.html#Lean.rawStx.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L483-L487","name":"Lean.Parser.Category.rawStx","docLink":"./Init/Notation.html#Lean.Parser.Category.rawStx","doc":"Category for carrying raw syntax trees between macros; any content is printed as is by the pretty printer.\nThe only accepted parser for this category is an antiquotation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L480-L481","name":"Lean.termThis","docLink":"./Init/Notation.html#Lean.termThis","doc":"Special identifier introduced by \"anonymous\" `have : ...`, `suffices p ...` etc. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L454-L460","name":"«term%[_|_]»","docLink":"./Init/Notation.html#«term%[_|_]»","doc":"Auxiliary syntax for implementing `[$elem,*]` list literal syntax.\nThe syntax `%[a,b,c|tail]` constructs a value equivalent to `a::b::c::tail`.\nIt uses binary partitioning to construct a tree of intermediate let bindings as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L441-L452","name":"«term[_]»","docLink":"./Init/Notation.html#«term[_]»","doc":"The syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L439-L439","name":"termWithout_expected_type_","docLink":"./Init/Notation.html#termWithout_expected_type_","doc":"`without_expected_type t` instructs Lean to elaborate `t` without an expected type.\nRecall that terms such as `match ... with ...` and `⟨...⟩` will postpone elaboration until\nexpected type is known. So, `without_expected_type` is not effective in this case.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L428-L428","name":"«term{_:_//_}»","docLink":"./Init/Notation.html#«term{_:_//_}»","doc":"`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L416-L422","name":"«term_$__»","docLink":"./Init/Notation.html#«term_$__»","doc":"Alternative syntax for `<|`. `f $ x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f $ g $ x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L406-L410","name":"«term_|>_»","docLink":"./Init/Notation.html#«term_|>_»","doc":"Haskell-like pipe operator `|>`. `x |> f` means the same as the same as `f x`,\nand it chains such that `x |> f |> g` is interpreted as `g (f x)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L395-L400","name":"«term_<|_»","docLink":"./Init/Notation.html#«term_<|_»","doc":"Haskell-like pipe operator `<|`. `f <| x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L388-L390","name":"boolIfThenElse","docLink":"./Init/Notation.html#boolIfThenElse","doc":"`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L385-L386","name":"«termIfLet_:=_Then_Else_»","docLink":"./Init/Notation.html#«termIfLet_:=_Then_Else_»","doc":"`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat => t\n| _ => e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L366-L368","name":"termIfThenElse","docLink":"./Init/Notation.html#termIfThenElse","doc":"`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L354-L356","name":"termDepIfThenElse","docLink":"./Init/Notation.html#termDepIfThenElse","doc":"\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr ⟨i, h⟩` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get ⟨i, h⟩ else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L345-L349","name":"Lean.Parser.Tactic.caseArg","docLink":"./Init/Notation.html#Lean.Parser.Tactic.caseArg","doc":"A case tag argument has the form `tag x₁ ... xₙ`; it refers to tag `tag` and renames\nthe last `n` hypotheses to `x₁ ... xₙ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L337-L341","name":"Lean.binderIdent","docLink":"./Init/Notation.html#Lean.binderIdent","doc":"`binderIdent` matches an `ident` or a `_`. It is used for identifiers in binding\nposition, where `_` means that the value should be left unnamed and inaccessible.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L330-L330","name":"«term_<$>_»","docLink":"./Init/Notation.html#«term_<$>_»","doc":"If `f : α → β` and `x : F α` then `f <$> x : F β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L329-L329","name":"«term_*>_»","docLink":"./Init/Notation.html#«term_*>_»","doc":"If `x : F α` and `y : F β`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L328-L328","name":"«term_<*_»","docLink":"./Init/Notation.html#«term_<*_»","doc":"If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L327-L327","name":"«term_<*>_»","docLink":"./Init/Notation.html#«term_<*>_»","doc":"If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\nIn a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit → f α` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L326-L326","name":"«term_>>=_»","docLink":"./Init/Notation.html#«term_>>=_»","doc":"If `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the\nresult of executing `x` to get a value of type `α` and then passing it to `f`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L325-L325","name":"«term_>>_»","docLink":"./Init/Notation.html#«term_>>_»","doc":"`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L324-L324","name":"«term_<|>_»","docLink":"./Init/Notation.html#«term_<|>_»","doc":"`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L323-L323","name":"«term_::_»","docLink":"./Init/Notation.html#«term_::_»","doc":"If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L320-L321","name":"«term_∉_»","docLink":"./Init/Notation.html#«term_∉_»","doc":"`a ∉ b` is negated elementhood. It is notation for `¬ (a ∈ b)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L319-L319","name":"«term_∈_»","docLink":"./Init/Notation.html#«term_∈_»","doc":"The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L317-L317","name":"term!_","docLink":"./Init/Notation.html#term!_","doc":"`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L316-L316","name":"«term_||_»","docLink":"./Init/Notation.html#«term_||_»","doc":"`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L315-L315","name":"«term_&&_»","docLink":"./Init/Notation.html#«term_&&_»","doc":"`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L313-L313","name":"«term¬_»","docLink":"./Init/Notation.html#«term¬_»","doc":"`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L312-L312","name":"«term_∨_»","docLink":"./Init/Notation.html#«term_∨_»","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L311-L311","name":"«term_\\/_»","docLink":"./Init/Notation.html#«term_\\/_»","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L310-L310","name":"«term_∧_»","docLink":"./Init/Notation.html#«term_∧_»","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L309-L309","name":"«term_/\\_»","docLink":"./Init/Notation.html#«term_/\\_»","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L293-L293","name":"«term_==_»","docLink":"./Init/Notation.html#«term_==_»","doc":"Boolean equality, notated as `a == b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L292-L292","name":"«term_=_»","docLink":"./Init/Notation.html#«term_=_»","doc":"The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L291-L291","name":"«term_>_»","docLink":"./Init/Notation.html#«term_>_»","doc":"`a > b` is an abbreviation for `b < a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L290-L290","name":"«term_≥_»","docLink":"./Init/Notation.html#«term_≥_»","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L289-L289","name":"«term_>=_»","docLink":"./Init/Notation.html#«term_>=_»","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L288-L288","name":"«term_<_»","docLink":"./Init/Notation.html#«term_<_»","doc":"The less-than relation: `x < y` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L287-L287","name":"«term_≤_»","docLink":"./Init/Notation.html#«term_≤_»","doc":"The less-equal relation: `x ≤ y` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L286-L286","name":"«term_<=_»","docLink":"./Init/Notation.html#«term_<=_»","doc":"The less-equal relation: `x ≤ y` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L267-L267","name":"«term~~~_»","docLink":"./Init/Notation.html#«term~~~_»","doc":"The implementation of `~~~a : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L266-L266","name":"«term-_»","docLink":"./Init/Notation.html#«term-_»","doc":"`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L265-L265","name":"«term_++_»","docLink":"./Init/Notation.html#«term_++_»","doc":"`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L264-L264","name":"«term_^_»","docLink":"./Init/Notation.html#«term_^_»","doc":"`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L263-L263","name":"«term_>>>_»","docLink":"./Init/Notation.html#«term_>>>_»","doc":"`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L262-L262","name":"«term_<<<_»","docLink":"./Init/Notation.html#«term_<<<_»","doc":"`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L261-L261","name":"«term_%_»","docLink":"./Init/Notation.html#«term_%_»","doc":"`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int`, `a % 0` is defined to be `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L260-L260","name":"«term_/_»","docLink":"./Init/Notation.html#«term_/_»","doc":"`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat` and `Int`, `a / b` rounds toward 0.\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L259-L259","name":"«term_*_»","docLink":"./Init/Notation.html#«term_*_»","doc":"`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L258-L258","name":"«term_-_»","docLink":"./Init/Notation.html#«term_-_»","doc":"`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L257-L257","name":"«term_+_»","docLink":"./Init/Notation.html#«term_+_»","doc":"`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L256-L256","name":"«term_&&&_»","docLink":"./Init/Notation.html#«term_&&&_»","doc":"`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L255-L255","name":"«term_^^^_»","docLink":"./Init/Notation.html#«term_^^^_»","doc":"`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L254-L254","name":"«term_|||_»","docLink":"./Init/Notation.html#«term_|||_»","doc":"`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L252-L252","name":"«term_×_»","docLink":"./Init/Notation.html#«term_×_»","doc":"Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L251-L251","name":"«term_∘_»","docLink":"./Init/Notation.html#«term_∘_»","doc":"Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L239-L249","name":"rawNatLit","docLink":"./Init/Notation.html#rawNatLit","doc":"The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L237-L237","name":"stx!_","docLink":"./Init/Notation.html#stx!_","doc":"`!p` parses the negation of `p`. That is, it fails if `p` succeeds, and\notherwise parses nothing. It has arity 0.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L231-L231","name":"«stx_,+,?»","docLink":"./Init/Notation.html#«stx_,+,?»","doc":"`p,+,?` is shorthand for `sepBy1(p, \",\", allowTrailingSep)`.\nIt parses 1 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L221-L221","name":"«stx_,*,?»","docLink":"./Init/Notation.html#«stx_,*,?»","doc":"`p,*,?` is shorthand for `sepBy(p, \",\", allowTrailingSep)`.\nIt parses 0 or more occurrences of `p` separated by `,`, possibly including\na trailing `,`, that is: `empty | p | p, | p,p | p,p, | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L211-L211","name":"«stx_,+»","docLink":"./Init/Notation.html#«stx_,+»","doc":"`p,+` is shorthand for `sepBy(p, \",\")`. It parses 1 or more occurrences of\n`p` separated by `,`, that is: `p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L203-L203","name":"«stx_,*»","docLink":"./Init/Notation.html#«stx_,*»","doc":"`p,*` is shorthand for `sepBy(p, \",\")`. It parses 0 or more occurrences of\n`p` separated by `,`, that is: `empty | p | p,p | p,p,p | ...`.\n\nIt produces a `nullNode` containing a `SepArray` with the interleaved parser\nresults. It has arity 1, and auto-groups its component parser if needed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L173-L188","name":"«stx_<|>_»","docLink":"./Init/Notation.html#«stx_<|>_»","doc":"`p1 <|> p2` is shorthand for `orelse(p1, p2)`, and parses either `p1` or `p2`.\nIt does not backtrack, meaning that if `p1` consumes at least one token then\n`p2` will not be tried. Therefore, the parsers should all differ in their first\ntoken. The `atomic(p)` parser combinator can be used to locally backtrack a parser.\n(For full backtracking, consider using extensible syntax classes instead.)\n\nOn success, if the inner parser does not generate exactly one node, it will be\nautomatically wrapped in a `group` node, so the result will always be arity 1.\n\nThe `<|>` combinator does not generate a node of its own, and in particular\ndoes not tag the inner parsers to distinguish them, which can present a problem\nwhen reconstructing the parse. A well formed `<|>` parser should use disjoint\nnode kinds for `p1` and `p2`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L160-L171","name":"stx_?","docLink":"./Init/Notation.html#stx_?","doc":"`(p)?` is shorthand for `optional(p)`. It uses parser `p` 0 or 1 times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\n`p` is allowed to have arity n > 1 (in which case the node will have either 0 or n children),\nbut if it has arity 0 then the result will be ambiguous.\n\nBecause `?` is an identifier character, `ident?` will not work as intended.\nYou have to write either `ident ?` or `(ident)?` for it to parse as the `?` combinator\napplied to the `ident` parser.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L152-L158","name":"«stx_*»","docLink":"./Init/Notation.html#«stx_*»","doc":"`p*` is shorthand for `many(p)`. It uses parser `p` 0 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L144-L150","name":"«stx_+»","docLink":"./Init/Notation.html#«stx_+»","doc":"`p+` is shorthand for `many1(p)`. It uses parser `p` 1 or more times, and produces a\n`nullNode` containing the array of parsed results. This parser has arity 1.\n\nIf `p` has arity more than 1, it is auto-grouped in the items generated by the parser.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L139-L139","name":"«prio(_)»","docLink":"./Init/Notation.html#«prio(_)»","doc":"Parentheses are used for grouping priority expressions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L137-L137","name":"prioHigh","docLink":"./Init/Notation.html#prioHigh","doc":"The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L135-L135","name":"prioMid","docLink":"./Init/Notation.html#prioMid","doc":"The standardized \"medium\" priority `med = 1000`. This is the same as `default`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L133-L133","name":"prioLow","docLink":"./Init/Notation.html#prioLow","doc":"The standardized \"low\" priority `low = 100`, for things that should be lower than default priority. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L131-L131","name":"prioDefault","docLink":"./Init/Notation.html#prioDefault","doc":"The default priority `default = 1000`, which is used when no priority is set. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L128-L128","name":"termMax_prec","docLink":"./Init/Notation.html#termMax_prec","doc":"`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L123-L123","name":"precMin1","docLink":"./Init/Notation.html#precMin1","doc":"`(min+1)` (we can only write `min+1` after `Meta.lean`) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L121-L121","name":"precMin","docLink":"./Init/Notation.html#precMin","doc":"Minimum precedence used in term parsers. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L119-L119","name":"«prec(_)»","docLink":"./Init/Notation.html#«prec(_)»","doc":"Parentheses are used for grouping precedence expressions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L117-L117","name":"precLead","docLink":"./Init/Notation.html#precLead","doc":"Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L115-L115","name":"precArg","docLink":"./Init/Notation.html#precArg","doc":"Precedence used for application arguments (`do`, `by`, ...). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L113-L113","name":"precMax","docLink":"./Init/Notation.html#precMax","doc":"Maximum precedence used in term parsers, in particular for terms in\nfunction position (`ident`, `paren`, ...)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L104-L105","name":"Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","docLink":"./Init/Notation.html#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L101-L102","name":"Lean.instCoeHeadTSyntaxSyntax","docLink":"./Init/Notation.html#Lean.instCoeHeadTSyntaxSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L96-L97","name":"Lean.Parser.Syntax.subPrio","docLink":"./Init/Notation.html#Lean.Parser.Syntax.subPrio","doc":"Subtraction of priorities. This is normally used only for offseting, e.g. `default - 1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L94-L95","name":"Lean.Parser.Syntax.addPrio","docLink":"./Init/Notation.html#Lean.Parser.Syntax.addPrio","doc":"Addition of priorities. This is normally used only for offseting, e.g. `default + 1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L91-L92","name":"Lean.Parser.Syntax.subPrec","docLink":"./Init/Notation.html#Lean.Parser.Syntax.subPrec","doc":"Subtraction of precedences. This is normally used only for offseting, e.g. `max - 1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L89-L90","name":"Lean.Parser.Syntax.addPrec","docLink":"./Init/Notation.html#Lean.Parser.Syntax.addPrec","doc":"Addition of precedences. This is normally used only for offseting, e.g. `max + 1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L81-L81","name":"Lean.Parser.Category.prec","docLink":"./Init/Notation.html#Lean.Parser.Category.prec","doc":"`prec` is a builtin syntax category for precedences. A precedence is a value\nthat expresses how tightly a piece of syntax binds: for example `1 + 2 * 3` is\nparsed as `1 + (2 * 3)` because `*` has a higher pr0ecedence than `+`.\nHigher numbers denote higher precedence.\nIn addition to literals like `37`, there are some special named priorities:\n* `arg` for the precedence of function arguments\n* `max` for the highest precedence used in term parsers (not actually the maximum possible value)\n* `lead` for the precedence of terms not supposed to be used as arguments\nand you can also add and subtract precedences. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L70-L70","name":"Lean.Parser.Category.prio","docLink":"./Init/Notation.html#Lean.Parser.Category.prio","doc":"`prio` is a builtin syntax category for priorities.\nPriorities are used in many different attributes.\nHigher numbers denote higher priority, and for example typeclass search will\ntry high priority instances before low priority.\nIn addition to literals like `37`, you can also use `low`, `mid`, `high`, as well as\nadd and subtract priorities. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L62-L62","name":"Lean.Parser.Category.stx","docLink":"./Init/Notation.html#Lean.Parser.Category.stx","doc":"`stx` is a builtin syntax category for syntax. This is the abbreviated\nparser notation used inside `syntax` and `macro` declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L58-L58","name":"Lean.Parser.Category.attr","docLink":"./Init/Notation.html#Lean.Parser.Category.attr","doc":"`attr` is a builtin syntax category for attributes.\nDeclarations can be annotated with attributes using the `@[...]` notation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L54-L54","name":"Lean.Parser.Category.level","docLink":"./Init/Notation.html#Lean.Parser.Category.level","doc":"`level` is a builtin syntax category for universe levels.\nThis is the `u` in `Sort u`: it can contain `max` and `imax`, addition with\nconstants, and variables. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L49-L49","name":"Lean.Parser.Category.doElem","docLink":"./Init/Notation.html#Lean.Parser.Category.doElem","doc":"`doElem` is a builtin syntax category for elements that can appear in the `do` notation.\nFor example, `let x ← e` is a `doElem`, and a `do` block consists of a list of `doElem`s. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L45-L45","name":"Lean.Parser.Category.tactic","docLink":"./Init/Notation.html#Lean.Parser.Category.tactic","doc":"`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L35-L35","name":"Lean.Parser.Category.term","docLink":"./Init/Notation.html#Lean.Parser.Category.term","doc":"`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L28-L28","name":"Lean.Parser.Category.command","docLink":"./Init/Notation.html#Lean.Parser.Category.command","doc":"`command` is the syntax category for things that appear at the top level\nof a lean file. For example, `def foo := 1` is a `command`, as is\n`namespace Foo` and `end Foo`. Commands generally have an effect on the state of\nadding something to the environment (like a new definition), as well as\ncommands like `variable` which modify future commands within a scope. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/23ba495205f8133628d85dde572aad0c1089c094/src/Init/Notation.lean#L19-L19","name":"Lean.Parser.Category","docLink":"./Init/Notation.html#Lean.Parser.Category","doc":"Auxiliary type used to represent syntax categories. We mainly use auxiliary\ndefinitions with this type to attach doc strings to syntax categories.\n"}]}