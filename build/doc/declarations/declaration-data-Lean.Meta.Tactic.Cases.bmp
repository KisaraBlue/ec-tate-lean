{"name":"Lean.Meta.Tactic.Cases","instances":[],"imports":["Init","Lean.Meta.AppBuilder","Lean.Meta.Tactic.Induction","Lean.Meta.Tactic.Injection","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Subst","Lean.Meta.Tactic.Acyclic","Lean.Meta.Tactic.UnifyEq"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L311-L316","name":"Lean.MVarId.byCases","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.MVarId.byCases","doc":"Split the goal in two subgoals: one containing the hypothesis `h : p` and another containing `h : ¬ p`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L300-L302","name":"Lean.Meta.ByCasesSubgoal","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.ByCasesSubgoal","doc":"Auxiliary structure for storing `byCases` tactic result. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L293-L297","name":"Lean.MVarId.substEqs","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.MVarId.substEqs","doc":"Applies `cases` to any hypothesis of the form `h : r = s`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L286-L288","name":"Lean.MVarId.casesAnd","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.MVarId.casesAnd","doc":"Applies `cases` (recursively) to any hypothesis of the form `h : p ∧ q`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L271-L281","name":"Lean.MVarId.casesRec","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.MVarId.casesRec","doc":"Keep applying `cases` on any hypothesis that satisfies `p`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L265-L266","name":"Lean.Meta.cases","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.cases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L261-L262","name":"Lean.MVarId.cases","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.MVarId.cases","doc":"Apply `casesOn` using the free variable `majorFVarId` as the major premise (aka discriminant).\n`givenNames` contains user-facing names for each alternative.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L232-L253","name":"Lean.Meta.Cases.cases","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.Cases.cases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L202-L210","name":"Lean.Meta.Cases.unifyEqs?","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.Cases.unifyEqs?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L129-L136","name":"Lean.Meta.Cases.Context","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.Cases.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L124-L125","name":"Lean.Meta.CasesSubgoal","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.CasesSubgoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L85-L122","name":"Lean.Meta.generalizeIndices","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.generalizeIndices","doc":"Similar to `generalizeTargets` but customized for the `casesOn` motive.\nGiven a metavariable `mvarId` representing the\n```\nCtx, h : I A j, D |- T\n```\nwhere `fvarId` is `h`s id, and the type `I A j` is an inductive datatype where `A` are parameters,\nand `j` the indices. Generate the goal\n```\nCtx, h : I A j, D, j' : J, h' : I A j' |- j == j' -> h == h' -> T\n```\nRemark: `(j == j' -> h == h')` is a \"telescopic\" equality.\nRemark: `j` is sequence of terms, and `j'` a sequence of free variables.\nThe result contains the fields\n- `mvarId`: the new goal\n- `indicesFVarIds`: `j'` ids\n- `fvarId`: `h'` id\n- `numEqs`: number of equations in the target "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L61-L65","name":"Lean.Meta.GeneralizeIndicesSubgoal","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.GeneralizeIndicesSubgoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L45-L59","name":"Lean.Meta.generalizeTargetsEq","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.generalizeTargetsEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Meta/Tactic/Cases.lean#L19-L24","name":"Lean.Meta.getInductiveUniverseAndParams","docLink":"./Lean/Meta/Tactic/Cases.html#Lean.Meta.getInductiveUniverseAndParams","doc":""}]}