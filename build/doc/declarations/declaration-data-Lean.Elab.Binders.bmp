{"name":"Lean.Elab.Binders","instances":[],"imports":["Init","Lean.Elab.Quotation.Precheck","Lean.Elab.Term","Lean.Elab.BindersUtil"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L760-L761","name":"Lean.Elab.Term.elabLetTmpDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetTmpDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L757-L758","name":"Lean.Elab.Term.elabLetDelayedDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDelayedDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L754-L755","name":"Lean.Elab.Term.elabLetFunDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetFunDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L751-L752","name":"Lean.Elab.Term.elabLetDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L717-L749","name":"Lean.Elab.Term.elabLetDeclCore","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDeclCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L711-L715","name":"Lean.Elab.Term.expandLetEqnsDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandLetEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L702-L709","name":"Lean.Elab.Term.mkLetIdDeclView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.mkLetIdDeclView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L696-L700","name":"Lean.Elab.Term.LetIdDeclView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.LetIdDeclView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L646-L694","name":"Lean.Elab.Term.elabLetDeclAux","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDeclAux","doc":"If `useLetExpr` is true, then a kernel let-expression `let x : type := val; body` is created.\nOtherwise, we create a term of the form `(fun (x : type) => body) val`\n\nThe default elaboration order is `binders`, `typeStx`, `valStx`, and `body`.\nIf `elabBodyFirst == true`, then we use the order `binders`, `typeStx`, `body`, and `valStx`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L626-L639","name":"Lean.Elab.Term.elabFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L615-L624","name":"Lean.Elab.Term.precheckFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.precheckFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L609-L612","name":"Lean.Elab.Term.expandExplicitFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandExplicitFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L596-L607","name":"Lean.Elab.Term.expandFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L582-L593","name":"Lean.Elab.Term.expandMatchAltsWhereDecls.loop","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsWhereDecls.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L579-L594","name":"Lean.Elab.Term.expandMatchAltsWhereDecls","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsWhereDecls","doc":"Similar to `expandMatchAltsIntoMatch`, but supports an optional `where` clause.\n\nExpand `matchAltsWhereDecls` into `let rec` + `match`-expression.\nExample\n```\n| 0, true => ... f 0 ...\n| i, _    => ... f i + g i ...\nwhere\n  f x := g x + 1\n\n  g : Nat → Nat\n    | 0   => 1\n    | x+1 => f x\n```\nexpands into\n```\nfux x_1 x_2 =>\n  let rec\n    f x := g x + 1,\n    g : Nat → Nat\n      | 0   => 1\n      | x+1 => f x\n  match x_1, x_2 with\n  | 0, true => ... f 0 ...\n  | i, _    => ... f i + g i ...\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L548-L549","name":"Lean.Elab.Term.expandMatchAltsIntoMatchTactic","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsIntoMatchTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L545-L546","name":"Lean.Elab.Term.expandMatchAltsIntoMatch","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsIntoMatch","doc":"Expand `matchAlts` syntax into a full `match`-expression.\nExample:\n```\n| 0, true => alt_1\n| i, _    => alt_2\n```\nexpands into (for tactic == false)\n```\nfun x_1 x_2 =>\nmatch @x_1, @x_2 with\n| 0, true => alt_1\n| i, _    => alt_2\n```\nand (for tactic == true)\n```\nintro x_1; intro x_2;\nmatch @x_1, @x_2 with\n| 0, true => alt_1\n| i, _    => alt_2\n```\n\nIf `useExplicit = true`, we add a `@` before `fun` to disable implicit lambdas. We disable them when processing `let` and `let rec` declarations\nto make sure the behavior is consistent with top-level declarations where we can write\n```\ndef f : {α : Type} → α → α\n  | _, a => a\n```\nWe use `useExplicit = false` when we are elaborating the `fun | ... => ... | ...` notation. See issue #1132.\nIf `@fun` is used with this notation, the we set `useExplicit = true`.\nWe also use `useExplicit = false` when processing `instance ... where` notation declarations. The motivation is to have compact declarations such as\n```\ninstance [Alternative m] : MonadLiftT Option m where\nmonadLift -- We don't want to provide the implicit arguments of `monadLift` here. One should use `monadLift := @fun ...` if they want to provide them.\n  | some a => pure a\n  | none => failure\n```\n\nRemark: we add `@` at discriminants to make sure we don't consume implicit arguments, and to make the behavior consistent with `fun`.\nExample:\n```\ninductive T : Type 1 :=\n| mkT : (forall {a : Type}, a -> a) -> T\n\ndef makeT (f : forall {a : Type}, a -> a) : T :=\n  mkT f\n\ndef makeT' : (forall {a : Type}, a -> a) -> T\n| f => mkT f\n```\nThe two definitions should be elaborated without errors and be equivalent.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L466-L470","name":"Lean.Elab.Term.expandWhereDeclsOpt","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandWhereDeclsOpt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L461-L464","name":"Lean.Elab.Term.expandWhereDecls","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandWhereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L451-L459","name":"Lean.Elab.Term.elabFunBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabFunBinders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L441-L447","name":"Lean.Elab.Term.FunBinders.elabFunBindersAux","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.FunBinders.elabFunBindersAux","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L392-L396","name":"Lean.Elab.Term.FunBinders.State","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.FunBinders.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L339-L387","name":"Lean.Elab.Term.expandFunBinders.loop","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFunBinders.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L338-L388","name":"Lean.Elab.Term.expandFunBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFunBinders","doc":"Auxiliary function for expanding `fun` notation binders. Recall that `fun` parser is defined as\n```\ndef funBinder : Parser := implicitBinder <|> instBinder <|> termParser maxPrec\nleading_parser unicodeSymbol \"λ\" \"fun\" >> many1 funBinder >> \"=>\" >> termParser\n```\nto allow notation such as `fun (a, b) => a + b`, where `(a, b)` should be treated as a pattern.\nThe result is a pair `(explicitBinders, newBody)`, where `explicitBinders` is syntax of the form\n```\n`(` ident `:` term `)`\n```\nwhich can be elaborated using `elabBinders`, and `newBody` is the updated `body` syntax.\nWe update the `body` syntax when expanding the pattern notation.\nExample: `fun (a, b) => a + b` expands into `fun _a_1 => match _a_1 with | (a, b) => a + b`.\nSee local function `processAsPattern` at `expandFunBindersAux`.\n\nThe resulting `Bool` is true if a pattern was found. We use it \"mark\" a macro expansion. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L288-L293","name":"Lean.Elab.Term.elabDepArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabDepArrow","doc":"The dependent arrow. `(x : α) → β` is equivalent to `∀ x : α, β`, but we usually\nreserve the latter for propositions. Also written as `Π x : α, β` (the \"Pi-type\")\nin the literature. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L275-L282","name":"Lean.Elab.Term.elabArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L269-L273","name":"Lean.Elab.Term.precheckArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.precheckArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L260-L266","name":"Lean.Elab.Term.elabForall","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L254-L258","name":"Lean.Elab.Term.expandForall","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L248-L252","name":"Lean.Elab.Term.expandSimpleBinderWithType","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandSimpleBinderWithType","doc":"If `binder` is a `_` or an identifier, return a `bracketedBinder` using `type` otherwise throw an exception. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L244-L245","name":"Lean.Elab.Term.elabBinder","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBinder","doc":"Same as `elabBinder` with a single binder."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L240-L241","name":"Lean.Elab.Term.elabBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBinders","doc":"Elaborate the given binders (i.e., `Syntax` objects for `bracketedBinder`),\nupdate the local context, set of local instances, reset instance chache (if needed), and then\nexecute `k` with the updated context.\nThe local context will only be included inside `k`.\n\nFor example, suppose you have binders `[(a : α), (b : β a)]`, then the elaborator will\ncreate two new free variables `a` and `b`, push these to the context and pass to `k #[a,b]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L224-L229","name":"Lean.Elab.Term.elabBindersEx","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBindersEx","doc":"Like `elabBinders`, but also pass syntax node per binder.\n`elabBinders(Ex)` automatically adds binder info nodes for the produced fvars, but storing the syntax nodes\nmight be necessary when later adding the same binders back to the local context so that info nodes can\nmanually be added for the new fvars; see `MutualDef` for an example. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L177-L180","name":"Lean.Elab.Term.checkBinderAnnotations","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.checkBinderAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L169-L170","name":"Lean.Elab.Term.addLocalVarInfo","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.addLocalVarInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L88-L100","name":"Lean.Elab.Term.declareTacticSyntax","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.declareTacticSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L71-L86","name":"Lean.Elab.Term.quoteAutoTactic","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.quoteAutoTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L65-L69","name":"Lean.Elab.Term.kindOfBinderName","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.kindOfBinderName","doc":"Determines the local declaration kind depending on the variable name.\n\nThe `__x` in `let __x := 42; body` gets kind `.implDetail`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9b406132070ba483ba6b7c698b8d76b59a67a16a/src/Lean/Elab/Binders.lean#L41-L58","name":"Lean.Elab.Term.BinderView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.BinderView","doc":"Auxiliary datatype for elaborating binders. "}]}